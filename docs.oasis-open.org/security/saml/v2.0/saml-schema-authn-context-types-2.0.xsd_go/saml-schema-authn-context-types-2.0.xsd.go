// Package goSamlAuthnContextTypes20 : autogenerated from XSD schema and manually adjusted (Nicola Asuni - 2016-11-03)
package goSamlAuthnContextTypes20

//	Document identifier: saml-schema-authn-context-types-2.0 Location: http://docs.oasis-open.org/security/saml/v2.0/ Revision history: V2.0 (March, 2005): New core authentication context schema types for SAML V2.0.

import (
	xsdt "github.com/miracl/go-xsd-pkg/xsdt"
)

// XAttrGoverningAgreementRefXsdtAnyURI A particular assertion on an identity
// provider's part with respect to the authentication
// context associated with an authentication assertion.
// Provides a mechanism for linking to external (likely
// human readable) documents in which additional business agreements,
// (e.g. liability constraints, obligations, etc) can be placed.
type XAttrGoverningAgreementRefXsdtAnyURI struct {
	GoverningAgreementRef xsdt.AnyURI `xml:"governingAgreementRef,attr,omitempty"`
}

// TGoverningAgreementRefType defines type GoverningAgreementRefType
type TGoverningAgreementRefType struct {
	XAttrGoverningAgreementRefXsdtAnyURI
}

// Walk : if the WalkHandlers.TGoverningAgreementRefType function is not nil (ie. was set by outside code), calls it with this TGoverningAgreementRefType instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TGoverningAgreementRefType instance.
func (me *TGoverningAgreementRefType) Walk() (err error) {
	if fn := WalkHandlers.TGoverningAgreementRefType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsGoverningAgreementRef defines element GoverningAgreementRef
type XElemsGoverningAgreementRef struct {
	GoverningAgreementRefs []*TGoverningAgreementRefType `xml:"GoverningAgreementRef"`
}

// Walk : if the WalkHandlers.XElemsGoverningAgreementRef function is not nil (ie. was set by outside code), calls it with this XElemsGoverningAgreementRef instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsGoverningAgreementRef instance.
func (me *XElemsGoverningAgreementRef) Walk() (err error) {
	if fn := WalkHandlers.XElemsGoverningAgreementRef; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.GoverningAgreementRefs {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TGoverningAgreementsType defines type GoverningAgreementsType
type TGoverningAgreementsType struct {
	XElemsGoverningAgreementRef
}

// Walk : if the WalkHandlers.TGoverningAgreementsType function is not nil (ie. was set by outside code), calls it with this TGoverningAgreementsType instance as the single argument. Then calls the Walk() method on 1/1 embed(s) and 0/0 field(s) belonging to this TGoverningAgreementsType instance.
func (me *TGoverningAgreementsType) Walk() (err error) {
	if fn := WalkHandlers.TGoverningAgreementsType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemsGoverningAgreementRef.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemGoverningAgreements defines element GoverningAgreements
type XElemGoverningAgreements struct {
	//	Provides a mechanism for linking to external (likely
	//	human readable) documents in which additional business agreements,
	//	(e.g. liability constraints, obligations, etc) can be placed.
	GoverningAgreements *TGoverningAgreementsType `xml:"GoverningAgreements"`
}

// Walk : if the WalkHandlers.XElemGoverningAgreements function is not nil (ie. was set by outside code), calls it with this XElemGoverningAgreements instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemGoverningAgreements instance.
func (me *XElemGoverningAgreements) Walk() (err error) {
	if fn := WalkHandlers.XElemGoverningAgreements; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.GoverningAgreements.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TExtensionType defines type ExtensionType
type TExtensionType struct {
}

// Walk : if the WalkHandlers.TExtensionType function is not nil (ie. was set by outside code), calls it with this TExtensionType instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/0 field(s) belonging to this TExtensionType instance.
func (me *TExtensionType) Walk() (err error) {
	if fn := WalkHandlers.TExtensionType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsExtension defines element Extension
type XElemsExtension struct {
	Extensions []*TExtensionType `xml:"Extension"`
}

// Walk : if the WalkHandlers.XElemsExtension function is not nil (ie. was set by outside code), calls it with this XElemsExtension instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsExtension instance.
func (me *XElemsExtension) Walk() (err error) {
	if fn := WalkHandlers.XElemsExtension; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Extensions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrIDXsdtID defines attribute Id
type XAttrIDXsdtID struct {
	ID xsdt.ID `xml:"ID,attr,omitempty"`
}

// TxsdPhysicalVerificationCredentialLevel Refers to those characteristics that describe the processes and mechanisms the Authentication Authority uses to initially create an association between a Principal and the identity (or name) by which the Principal will be known This element indicates that identification has been performed in a physical face-to-face meeting with the principal and not in an online manner.
type TxsdPhysicalVerificationCredentialLevel xsdt.Nmtoken

// IsPrimary : Returns true if the value of this enumerated TxsdPhysicalVerificationCredentialLevel is "primary".
func (me TxsdPhysicalVerificationCredentialLevel) IsPrimary() bool { return me.String() == "primary" }

// IsSecondary : Returns true if the value of this enumerated TxsdPhysicalVerificationCredentialLevel is "secondary".
func (me TxsdPhysicalVerificationCredentialLevel) IsSecondary() bool {
	return me.String() == "secondary"
}

// Set : Since TxsdPhysicalVerificationCredentialLevel is just a simple String type, this merely sets the current value from the specified string.
func (me *TxsdPhysicalVerificationCredentialLevel) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

// String : Since TxsdPhysicalVerificationCredentialLevel is just a simple String type, this merely returns the current string value.
func (me TxsdPhysicalVerificationCredentialLevel) String() string { return xsdt.Nmtoken(me).String() }

// ToXsdtNmtoken : This convenience method just performs a simple type conversion to TxsdPhysicalVerificationCredentialLevel's alias type xsdt.Nmtoken.
func (me TxsdPhysicalVerificationCredentialLevel) ToXsdtNmtoken() xsdt.Nmtoken {
	return xsdt.Nmtoken(me)
}

// XAttrCredentialLevelTxsdPhysicalVerificationCredentialLevel defines attribute CredentialLevelTxsdPhysicalVerificationCredentialLevel
type XAttrCredentialLevelTxsdPhysicalVerificationCredentialLevel struct {
	CredentialLevel TxsdPhysicalVerificationCredentialLevel `xml:"credentialLevel,attr,omitempty"`
}

// TxsdPhysicalVerification defines type xsdPhysicalVerification
type TxsdPhysicalVerification struct {
	XAttrCredentialLevelTxsdPhysicalVerificationCredentialLevel
}

// Walk : if the WalkHandlers.TxsdPhysicalVerification function is not nil (ie. was set by outside code), calls it with this TxsdPhysicalVerification instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TxsdPhysicalVerification instance.
func (me *TxsdPhysicalVerification) Walk() (err error) {
	if fn := WalkHandlers.TxsdPhysicalVerification; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemPhysicalVerification defines element PhysicalVerification
type XElemPhysicalVerification struct {
	//	This element indicates that identification has been
	//	performed in a physical
	//	face-to-face meeting with the principal and not in an
	//	online manner.
	PhysicalVerification *TxsdPhysicalVerification `xml:"PhysicalVerification"`
}

// Walk : if the WalkHandlers.XElemPhysicalVerification function is not nil (ie. was set by outside code), calls it with this XElemPhysicalVerification instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemPhysicalVerification instance.
func (me *XElemPhysicalVerification) Walk() (err error) {
	if fn := WalkHandlers.XElemPhysicalVerification; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.PhysicalVerification.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TExtensionOnlyType defines type ExtensionOnlyType
type TExtensionOnlyType struct {
	XElemsExtension
}

// Walk : if the WalkHandlers.TExtensionOnlyType function is not nil (ie. was set by outside code), calls it with this TExtensionOnlyType instance as the single argument. Then calls the Walk() method on 1/1 embed(s) and 0/0 field(s) belonging to this TExtensionOnlyType instance.
func (me *TExtensionOnlyType) Walk() (err error) {
	if fn := WalkHandlers.TExtensionOnlyType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemWrittenConsent defines element WrittenConsent
type XElemWrittenConsent struct {
	WrittenConsent *TExtensionOnlyType `xml:"WrittenConsent"`
}

// Walk : if the WalkHandlers.XElemWrittenConsent function is not nil (ie. was set by outside code), calls it with this XElemWrittenConsent instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemWrittenConsent instance.
func (me *XElemWrittenConsent) Walk() (err error) {
	if fn := WalkHandlers.XElemWrittenConsent; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.WrittenConsent.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TnymType This attribute indicates whether or not the
// Identification mechanisms allow the actions of the Principal to be
// linked to an actual end user.
type TnymType xsdt.Nmtoken

// Set : Since TnymType is just a simple String type, this merely sets the current value from the specified string.
func (me *TnymType) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

// String : Since TnymType is just a simple String type, this merely returns the current string value.
func (me TnymType) String() string { return xsdt.Nmtoken(me).String() }

// ToXsdtNmtoken : This convenience method just performs a simple type conversion to TnymType's alias type xsdt.Nmtoken.
func (me TnymType) ToXsdtNmtoken() xsdt.Nmtoken { return xsdt.Nmtoken(me) }

// IsAnonymity : Returns true if the value of this enumerated TnymType is "anonymity".
func (me TnymType) IsAnonymity() bool { return me.String() == "anonymity" }

// IsVerinymity : Returns true if the value of this enumerated TnymType is "verinymity".
func (me TnymType) IsVerinymity() bool { return me.String() == "verinymity" }

// IsPseudonymity : Returns true if the value of this enumerated TnymType is "pseudonymity".
func (me TnymType) IsPseudonymity() bool { return me.String() == "pseudonymity" }

// XAttrNymTnymType defines attribute NymTnymType
type XAttrNymTnymType struct {
	//	This attribute indicates whether or not the
	//	Identification mechanisms allow the actions of the Principal to be
	//	linked to an actual end user.
	Nym TnymType `xml:"nym,attr,omitempty"`
}

// TIdentificationType defines type IdentificationType
type TIdentificationType struct {
	XElemWrittenConsent
	XElemGoverningAgreements
	XElemsExtension
	//	This attribute indicates whether or not the
	//	Identification mechanisms allow the actions of the Principal to be
	//	linked to an actual end user.
	XAttrNymTnymType
	XElemPhysicalVerification
}

// Walk : if the WalkHandlers.TIdentificationType function is not nil (ie. was set by outside code), calls it with this TIdentificationType instance as the single argument. Then calls the Walk() method on 4/5 embed(s) and 0/0 field(s) belonging to this TIdentificationType instance.
func (me *TIdentificationType) Walk() (err error) {
	if fn := WalkHandlers.TIdentificationType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemPhysicalVerification.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemWrittenConsent.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemGoverningAgreements.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemIdentification defines element Identification
type XElemIdentification struct {
	//	Refers to those characteristics that describe the
	//	processes and mechanisms
	//	the Authentication Authority uses to initially create
	//	an association between a Principal
	//	and the identity (or name) by which the Principal will
	//	be known
	Identification *TIdentificationType `xml:"Identification"`
}

// Walk : if the WalkHandlers.XElemIdentification function is not nil (ie. was set by outside code), calls it with this XElemIdentification instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemIdentification instance.
func (me *XElemIdentification) Walk() (err error) {
	if fn := WalkHandlers.XElemIdentification; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Identification.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrMaxXsdtInteger Refers to those characterstics that describe how the 'secret' (the knowledge or possession of which allows the Principal to authenticate to the Authentication Authority) is kept secure This element indicates the types and strengths of facilities of a UA used to protect a shared secret key from unauthorized access and/or use. The actions that must be performed before the private key can be used. This element indicates that a Pin (Personal Identification Number) has been used to authenticate the Principal to some local system in order to activate a key. This element indicates the minimum and/or maximum ASCII length of the password which is enforced (by the UA or the IdP). In other words, this is the minimum and/or maximum number of ASCII characters required to represent a valid password. min - the minimum number of ASCII characters required in a valid password, as enforced by the UA or the IdP. max - the maximum number of ASCII characters required in a valid password, as enforced by the UA or the IdP.
type XAttrMaxXsdtInteger struct {
	Max xsdt.Integer `xml:"max,attr,omitempty"`
}

// XAttrMinXsdtInteger defines attribute Min
type XAttrMinXsdtInteger struct {
	Min xsdt.Integer `xml:"min,attr,omitempty"`
}

// TLengthType defines type LengthType
type TLengthType struct {
	XAttrMinXsdtInteger
	XAttrMaxXsdtInteger
}

// Walk : if the WalkHandlers.TLengthType function is not nil (ie. was set by outside code), calls it with this TLengthType instance as the single argument. Then calls the Walk() method on 0/2 embed(s) and 0/0 field(s) belonging to this TLengthType instance.
func (me *TLengthType) Walk() (err error) {
	if fn := WalkHandlers.TLengthType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemLength defines element Length
type XElemLength struct {
	//	This element indicates the minimum and/or maximum
	//	ASCII length of the password which is enforced (by the UA or the
	//	IdP). In other words, this is the minimum and/or maximum number of
	//	ASCII characters required to represent a valid password.
	//	min - the minimum number of ASCII characters required
	//	in a valid password, as enforced by the UA or the IdP.
	//	max - the maximum number of ASCII characters required
	//	in a valid password, as enforced by the UA or the IdP.
	Length *TLengthType `xml:"Length"`
}

// Walk : if the WalkHandlers.XElemLength function is not nil (ie. was set by outside code), calls it with this XElemLength instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemLength instance.
func (me *XElemLength) Walk() (err error) {
	if fn := WalkHandlers.XElemLength; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Length.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrExcludedCharsXsdtString defines attribute ExcludedChars
type XAttrExcludedCharsXsdtString struct {
	ExcludedChars xsdt.String `xml:"excludedChars,attr,omitempty"`
}

// XAttrCaseXsdtString defines attribute Case
type XAttrCaseXsdtString struct {
	Case xsdt.String `xml:"case,attr,omitempty"`
}

// XAttrRequiredCharsXsdtString defines attribute RequiredChars
type XAttrRequiredCharsXsdtString struct {
	RequiredChars xsdt.String `xml:"requiredChars,attr,omitempty"`
}

// TAlphabetType defines type AlphabetType
type TAlphabetType struct {
	XAttrRequiredCharsXsdtString
	XAttrExcludedCharsXsdtString
	XAttrCaseXsdtString
}

// Walk : if the WalkHandlers.TAlphabetType function is not nil (ie. was set by outside code), calls it with this TAlphabetType instance as the single argument. Then calls the Walk() method on 0/3 embed(s) and 0/0 field(s) belonging to this TAlphabetType instance.
func (me *TAlphabetType) Walk() (err error) {
	if fn := WalkHandlers.TAlphabetType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemAlphabet defines element Alphabet
type XElemAlphabet struct {
	Alphabet *TAlphabetType `xml:"Alphabet"`
}

// Walk : if the WalkHandlers.XElemAlphabet function is not nil (ie. was set by outside code), calls it with this XElemAlphabet instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemAlphabet instance.
func (me *XElemAlphabet) Walk() (err error) {
	if fn := WalkHandlers.XElemAlphabet; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Alphabet.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TxsdGenerationMechanism Indicates whether the password was chosen by the Principal or auto-supplied by the Authentication Authority. principalchosen - the Principal is allowed to choose the value of the password. This is true even if the initial password is chosen at random by the UA or the IdP and the Principal is then free to change the password. automatic - the password is chosen by the UA or the IdP to be cryptographically strong in some sense, or to satisfy certain password rules, and that the Principal is not free to change it or to choose a new password.
type TxsdGenerationMechanism xsdt.Nmtoken

// String : Since TxsdGenerationMechanism is just a simple String type, this merely returns the current string value.
func (me TxsdGenerationMechanism) String() string { return xsdt.Nmtoken(me).String() }

// ToXsdtNmtoken : This convenience method just performs a simple type conversion to TxsdGenerationMechanism's alias type xsdt.Nmtoken.
func (me TxsdGenerationMechanism) ToXsdtNmtoken() xsdt.Nmtoken { return xsdt.Nmtoken(me) }

// IsPrincipalchosen : Returns true if the value of this enumerated TxsdGenerationMechanism is "principalchosen".
func (me TxsdGenerationMechanism) IsPrincipalchosen() bool { return me.String() == "principalchosen" }

// IsAutomatic : Returns true if the value of this enumerated TxsdGenerationMechanism is "automatic".
func (me TxsdGenerationMechanism) IsAutomatic() bool { return me.String() == "automatic" }

// Set : Since TxsdGenerationMechanism is just a simple String type, this merely sets the current value from the specified string.
func (me *TxsdGenerationMechanism) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

// XAttrMechanismTxsdGenerationMechanism defines attribute MechanismTxsdGenerationMechanism
type XAttrMechanismTxsdGenerationMechanism struct {
	Mechanism TxsdGenerationMechanism `xml:"mechanism,attr,omitempty"`
}

// TxsdGeneration defines type xsdGeneration
type TxsdGeneration struct {
	XAttrMechanismTxsdGenerationMechanism
}

// Walk : if the WalkHandlers.TxsdGeneration function is not nil (ie. was set by outside code), calls it with this TxsdGeneration instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TxsdGeneration instance.
func (me *TxsdGeneration) Walk() (err error) {
	if fn := WalkHandlers.TxsdGeneration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemGeneration defines element Generation
type XElemGeneration struct {
	//	Indicates whether the password was chosen by the
	//	Principal or auto-supplied by the Authentication Authority.
	//	principalchosen - the Principal is allowed to choose
	//	the value of the password. This is true even if
	//	the initial password is chosen at random by the UA or
	//	the IdP and the Principal is then free to change
	//	the password.
	//	automatic - the password is chosen by the UA or the
	//	IdP to be cryptographically strong in some sense,
	//	or to satisfy certain password rules, and that the
	//	Principal is not free to change it or to choose a new password.
	Generation *TxsdGeneration `xml:"Generation"`
}

// Walk : if the WalkHandlers.XElemGeneration function is not nil (ie. was set by outside code), calls it with this XElemGeneration instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemGeneration instance.
func (me *XElemGeneration) Walk() (err error) {
	if fn := WalkHandlers.XElemGeneration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Generation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrDurationXsdtDuration This element indicates the length of time for which an
// PIN-based authentication is valid.
// This element indicates that the Key Activation Limit is
// defined as a specific duration of time.
type XAttrDurationXsdtDuration struct {
	Duration xsdt.Duration `xml:"duration,attr,omitempty"`
}

// TActivationLimitDurationType defines type ActivationLimitDurationType
type TActivationLimitDurationType struct {
	XAttrDurationXsdtDuration
}

// Walk : if the WalkHandlers.TActivationLimitDurationType function is not nil (ie. was set by outside code), calls it with this TActivationLimitDurationType instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TActivationLimitDurationType instance.
func (me *TActivationLimitDurationType) Walk() (err error) {
	if fn := WalkHandlers.TActivationLimitDurationType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemActivationLimitDuration defines element ActivationLimitDuration
type XElemActivationLimitDuration struct {
	//	This element indicates that the Key Activation Limit is
	//	defined as a specific duration of time.
	ActivationLimitDuration *TActivationLimitDurationType `xml:"ActivationLimitDuration"`
}

// Walk : if the WalkHandlers.XElemActivationLimitDuration function is not nil (ie. was set by outside code), calls it with this XElemActivationLimitDuration instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemActivationLimitDuration instance.
func (me *XElemActivationLimitDuration) Walk() (err error) {
	if fn := WalkHandlers.XElemActivationLimitDuration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ActivationLimitDuration.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrNumberXsdtInteger This element indicates that the Key Activation Limit is
// defined as a number of usages.
type XAttrNumberXsdtInteger struct {
	Number xsdt.Integer `xml:"number,attr,omitempty"`
}

// TActivationLimitUsagesType defines type ActivationLimitUsagesType
type TActivationLimitUsagesType struct {
	XAttrNumberXsdtInteger
}

// Walk : if the WalkHandlers.TActivationLimitUsagesType function is not nil (ie. was set by outside code), calls it with this TActivationLimitUsagesType instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TActivationLimitUsagesType instance.
func (me *TActivationLimitUsagesType) Walk() (err error) {
	if fn := WalkHandlers.TActivationLimitUsagesType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemActivationLimitUsages defines element ActivationLimitUsages
type XElemActivationLimitUsages struct {
	//	This element indicates that the Key Activation Limit is
	//	defined as a number of usages.
	ActivationLimitUsages *TActivationLimitUsagesType `xml:"ActivationLimitUsages"`
}

// Walk : if the WalkHandlers.XElemActivationLimitUsages function is not nil (ie. was set by outside code), calls it with this XElemActivationLimitUsages instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemActivationLimitUsages instance.
func (me *XElemActivationLimitUsages) Walk() (err error) {
	if fn := WalkHandlers.XElemActivationLimitUsages; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ActivationLimitUsages.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TActivationLimitSessionType This element indicates that the Key Activation Limit is
// the session.
type TActivationLimitSessionType struct {
}

// Walk : if the WalkHandlers.TActivationLimitSessionType function is not nil (ie. was set by outside code), calls it with this TActivationLimitSessionType instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/0 field(s) belonging to this TActivationLimitSessionType instance.
func (me *TActivationLimitSessionType) Walk() (err error) {
	if fn := WalkHandlers.TActivationLimitSessionType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemActivationLimitSession defines element ActivationLimitSession
type XElemActivationLimitSession struct {
	//	This element indicates that the Key Activation Limit is
	//	the session.
	ActivationLimitSession *TActivationLimitSessionType `xml:"ActivationLimitSession"`
}

// Walk : if the WalkHandlers.XElemActivationLimitSession function is not nil (ie. was set by outside code), calls it with this XElemActivationLimitSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemActivationLimitSession instance.
func (me *XElemActivationLimitSession) Walk() (err error) {
	if fn := WalkHandlers.XElemActivationLimitSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ActivationLimitSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TActivationLimitType defines type ActivationLimitType
type TActivationLimitType struct {
	XElemActivationLimitUsages
	XElemActivationLimitSession
	XElemActivationLimitDuration
}

// Walk : if the WalkHandlers.TActivationLimitType function is not nil (ie. was set by outside code), calls it with this TActivationLimitType instance as the single argument. Then calls the Walk() method on 3/3 embed(s) and 0/0 field(s) belonging to this TActivationLimitType instance.
func (me *TActivationLimitType) Walk() (err error) {
	if fn := WalkHandlers.TActivationLimitType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemActivationLimitDuration.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemActivationLimitUsages.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemActivationLimitSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemActivationLimit defines element ActivationLimit
type XElemActivationLimit struct {
	//	This element indicates the length of time for which an
	//	PIN-based authentication is valid.
	ActivationLimit *TActivationLimitType `xml:"ActivationLimit"`
}

// Walk : if the WalkHandlers.XElemActivationLimit function is not nil (ie. was set by outside code), calls it with this XElemActivationLimit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemActivationLimit instance.
func (me *XElemActivationLimit) Walk() (err error) {
	if fn := WalkHandlers.XElemActivationLimit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ActivationLimit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TActivationPinType defines type ActivationPinType
type TActivationPinType struct {
	XElemAlphabet
	XElemGeneration
	XElemActivationLimit
	XElemsExtension
	XElemLength
}

// Walk : if the WalkHandlers.TActivationPinType function is not nil (ie. was set by outside code), calls it with this TActivationPinType instance as the single argument. Then calls the Walk() method on 5/5 embed(s) and 0/0 field(s) belonging to this TActivationPinType instance.
func (me *TActivationPinType) Walk() (err error) {
	if fn := WalkHandlers.TActivationPinType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemLength.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemAlphabet.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemGeneration.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemActivationLimit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemActivationPin defines element ActivationPin
type XElemActivationPin struct {
	//	This element indicates that a Pin (Personal
	//	Identification Number) has been used to authenticate the Principal to
	//	some local system in order to activate a key.
	ActivationPin *TActivationPinType `xml:"ActivationPin"`
}

// Walk : if the WalkHandlers.XElemActivationPin function is not nil (ie. was set by outside code), calls it with this XElemActivationPin instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemActivationPin instance.
func (me *XElemActivationPin) Walk() (err error) {
	if fn := WalkHandlers.XElemActivationPin; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ActivationPin.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TKeyActivationType defines type KeyActivationType
type TKeyActivationType struct {
	XElemActivationPin
	XElemsExtension
}

// Walk : if the WalkHandlers.TKeyActivationType function is not nil (ie. was set by outside code), calls it with this TKeyActivationType instance as the single argument. Then calls the Walk() method on 2/2 embed(s) and 0/0 field(s) belonging to this TKeyActivationType instance.
func (me *TKeyActivationType) Walk() (err error) {
	if fn := WalkHandlers.TKeyActivationType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemActivationPin.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemKeyActivation defines element KeyActivation
type XElemKeyActivation struct {
	//	The actions that must be performed
	//	before the private key can be used.
	KeyActivation *TKeyActivationType `xml:"KeyActivation"`
}

// Walk : if the WalkHandlers.XElemKeyActivation function is not nil (ie. was set by outside code), calls it with this XElemKeyActivation instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemKeyActivation instance.
func (me *XElemKeyActivation) Walk() (err error) {
	if fn := WalkHandlers.XElemKeyActivation; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.KeyActivation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TmediumType In which medium is the key stored.
// memory - the key is stored in memory.
// smartcard - the key is stored in a smartcard.
// token - the key is stored in a hardware token.
// MobileDevice - the key is stored in a mobile device.
// MobileAuthCard - the key is stored in a mobile
// authentication card.
type TmediumType xsdt.Nmtoken

// Set : Since TmediumType is just a simple String type, this merely sets the current value from the specified string.
func (me *TmediumType) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

// String : Since TmediumType is just a simple String type, this merely returns the current string value.
func (me TmediumType) String() string { return xsdt.Nmtoken(me).String() }

// ToXsdtNmtoken : This convenience method just performs a simple type conversion to TmediumType's alias type xsdt.Nmtoken.
func (me TmediumType) ToXsdtNmtoken() xsdt.Nmtoken { return xsdt.Nmtoken(me) }

// IsMemory : Returns true if the value of this enumerated TmediumType is "memory".
func (me TmediumType) IsMemory() bool { return me.String() == "memory" }

// IsSmartcard : Returns true if the value of this enumerated TmediumType is "smartcard".
func (me TmediumType) IsSmartcard() bool { return me.String() == "smartcard" }

// IsToken : Returns true if the value of this enumerated TmediumType is "token".
func (me TmediumType) IsToken() bool { return me.String() == "token" }

// IsMobileDevice : Returns true if the value of this enumerated TmediumType is "MobileDevice".
func (me TmediumType) IsMobileDevice() bool { return me.String() == "MobileDevice" }

// IsMobileAuthCard : Returns true if the value of this enumerated TmediumType is "MobileAuthCard".
func (me TmediumType) IsMobileAuthCard() bool { return me.String() == "MobileAuthCard" }

// XAttrMediumTmediumType defines attribute MediumTmediumType
type XAttrMediumTmediumType struct {
	Medium TmediumType `xml:"medium,attr,omitempty"`
}

// TKeyStorageType defines type KeyStorageType
type TKeyStorageType struct {
	XAttrMediumTmediumType
}

// Walk : if the WalkHandlers.TKeyStorageType function is not nil (ie. was set by outside code), calls it with this TKeyStorageType instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TKeyStorageType instance.
func (me *TKeyStorageType) Walk() (err error) {
	if fn := WalkHandlers.TKeyStorageType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemKeyStorage defines element KeyStorage
type XElemKeyStorage struct {
	//	In which medium is the key stored.
	//	memory - the key is stored in memory.
	//	smartcard - the key is stored in a smartcard.
	//	token - the key is stored in a hardware token.
	//	MobileDevice - the key is stored in a mobile device.
	//	MobileAuthCard - the key is stored in a mobile
	//	authentication card.
	KeyStorage *TKeyStorageType `xml:"KeyStorage"`
}

// Walk : if the WalkHandlers.XElemKeyStorage function is not nil (ie. was set by outside code), calls it with this XElemKeyStorage instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemKeyStorage instance.
func (me *XElemKeyStorage) Walk() (err error) {
	if fn := WalkHandlers.XElemKeyStorage; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.KeyStorage.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TSecretKeyProtectionType defines type SecretKeyProtectionType
type TSecretKeyProtectionType struct {
	XElemKeyActivation
	XElemKeyStorage
	XElemsExtension
}

// Walk : if the WalkHandlers.TSecretKeyProtectionType function is not nil (ie. was set by outside code), calls it with this TSecretKeyProtectionType instance as the single argument. Then calls the Walk() method on 3/3 embed(s) and 0/0 field(s) belonging to this TSecretKeyProtectionType instance.
func (me *TSecretKeyProtectionType) Walk() (err error) {
	if fn := WalkHandlers.TSecretKeyProtectionType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemKeyActivation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemKeyStorage.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemSecretKeyProtection defines element SecretKeyProtection
type XElemSecretKeyProtection struct {
	//	This element indicates the types and strengths of
	//	facilities
	//	of a UA used to protect a shared secret key from
	//	unauthorized access and/or use.
	SecretKeyProtection *TSecretKeyProtectionType `xml:"SecretKeyProtection"`
}

// Walk : if the WalkHandlers.XElemSecretKeyProtection function is not nil (ie. was set by outside code), calls it with this XElemSecretKeyProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemSecretKeyProtection instance.
func (me *XElemSecretKeyProtection) Walk() (err error) {
	if fn := WalkHandlers.XElemSecretKeyProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SecretKeyProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrSharingXsdtBoolean This element indicates the types and strengths of
// facilities
// of a UA used to protect a private key from
// unauthorized access and/or use.
// Whether or not the private key is shared
// with the certificate authority.
type XAttrSharingXsdtBoolean struct {
	Sharing xsdt.Boolean `xml:"sharing,attr,omitempty"`
}

// TKeySharingType defines type KeySharingType
type TKeySharingType struct {
	XAttrSharingXsdtBoolean
}

// Walk : if the WalkHandlers.TKeySharingType function is not nil (ie. was set by outside code), calls it with this TKeySharingType instance as the single argument. Then calls the Walk() method on 0/1 embed(s) and 0/0 field(s) belonging to this TKeySharingType instance.
func (me *TKeySharingType) Walk() (err error) {
	if fn := WalkHandlers.TKeySharingType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemKeySharing defines element KeySharing
type XElemKeySharing struct {
	//	Whether or not the private key is shared
	//	with the certificate authority.
	KeySharing *TKeySharingType `xml:"KeySharing"`
}

// Walk : if the WalkHandlers.XElemKeySharing function is not nil (ie. was set by outside code), calls it with this XElemKeySharing instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemKeySharing instance.
func (me *XElemKeySharing) Walk() (err error) {
	if fn := WalkHandlers.XElemKeySharing; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.KeySharing.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TPrivateKeyProtectionType defines type PrivateKeyProtectionType
type TPrivateKeyProtectionType struct {
	XElemKeyActivation
	XElemKeyStorage
	XElemKeySharing
	XElemsExtension
}

// Walk : if the WalkHandlers.TPrivateKeyProtectionType function is not nil (ie. was set by outside code), calls it with this TPrivateKeyProtectionType instance as the single argument. Then calls the Walk() method on 4/4 embed(s) and 0/0 field(s) belonging to this TPrivateKeyProtectionType instance.
func (me *TPrivateKeyProtectionType) Walk() (err error) {
	if fn := WalkHandlers.TPrivateKeyProtectionType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemKeyActivation.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemKeyStorage.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemKeySharing.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemPrivateKeyProtection defines element PrivateKeyProtection
type XElemPrivateKeyProtection struct {
	//	This element indicates the types and strengths of
	//	facilities
	//	of a UA used to protect a private key from
	//	unauthorized access and/or use.
	PrivateKeyProtection *TPrivateKeyProtectionType `xml:"PrivateKeyProtection"`
}

// Walk : if the WalkHandlers.XElemPrivateKeyProtection function is not nil (ie. was set by outside code), calls it with this XElemPrivateKeyProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemPrivateKeyProtection instance.
func (me *XElemPrivateKeyProtection) Walk() (err error) {
	if fn := WalkHandlers.XElemPrivateKeyProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.PrivateKeyProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TechnicalProtectionBaseType defines type echnicalProtectionBaseType
type TechnicalProtectionBaseType struct {
	XElemPrivateKeyProtection
	XElemSecretKeyProtection
	XElemsExtension
}

// Walk : if the WalkHandlers.TechnicalProtectionBaseType function is not nil (ie. was set by outside code), calls it with this TechnicalProtectionBaseType instance as the single argument. Then calls the Walk() method on 3/3 embed(s) and 0/0 field(s) belonging to this TechnicalProtectionBaseType instance.
func (me *TechnicalProtectionBaseType) Walk() (err error) {
	if fn := WalkHandlers.TechnicalProtectionBaseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemPrivateKeyProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemSecretKeyProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemTechnicalProtection defines element TechnicalProtection
type XElemTechnicalProtection struct {
	//	Refers to those characterstics that describe how the
	//	'secret' (the knowledge or possession
	//	of which allows the Principal to authenticate to the
	//	Authentication Authority) is kept secure
	TechnicalProtection *TechnicalProtectionBaseType `xml:"TechnicalProtection"`
}

// Walk : if the WalkHandlers.XElemTechnicalProtection function is not nil (ie. was set by outside code), calls it with this XElemTechnicalProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemTechnicalProtection instance.
func (me *XElemTechnicalProtection) Walk() (err error) {
	if fn := WalkHandlers.XElemTechnicalProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.TechnicalProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemSwitchAudit Refers to those characteristics that describe
// procedural security controls employed by the Authentication Authority.
type XElemSwitchAudit struct {
	SwitchAudit *TExtensionOnlyType `xml:"SwitchAudit"`
}

// Walk : if the WalkHandlers.XElemSwitchAudit function is not nil (ie. was set by outside code), calls it with this XElemSwitchAudit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemSwitchAudit instance.
func (me *XElemSwitchAudit) Walk() (err error) {
	if fn := WalkHandlers.XElemSwitchAudit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SwitchAudit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TSecurityAuditType defines type SecurityAuditType
type TSecurityAuditType struct {
	XElemSwitchAudit
	XElemsExtension
}

// Walk : if the WalkHandlers.TSecurityAuditType function is not nil (ie. was set by outside code), calls it with this TSecurityAuditType instance as the single argument. Then calls the Walk() method on 2/2 embed(s) and 0/0 field(s) belonging to this TSecurityAuditType instance.
func (me *TSecurityAuditType) Walk() (err error) {
	if fn := WalkHandlers.TSecurityAuditType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemSwitchAudit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemSecurityAudit defines element SecurityAudit
type XElemSecurityAudit struct {
	SecurityAudit *TSecurityAuditType `xml:"SecurityAudit"`
}

// Walk : if the WalkHandlers.XElemSecurityAudit function is not nil (ie. was set by outside code), calls it with this XElemSecurityAudit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemSecurityAudit instance.
func (me *XElemSecurityAudit) Walk() (err error) {
	if fn := WalkHandlers.XElemSecurityAudit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SecurityAudit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemDeactivationCallCenter defines element DeactivationCallCenter
type XElemDeactivationCallCenter struct {
	DeactivationCallCenter *TExtensionOnlyType `xml:"DeactivationCallCenter"`
}

// Walk : if the WalkHandlers.XElemDeactivationCallCenter function is not nil (ie. was set by outside code), calls it with this XElemDeactivationCallCenter instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemDeactivationCallCenter instance.
func (me *XElemDeactivationCallCenter) Walk() (err error) {
	if fn := WalkHandlers.XElemDeactivationCallCenter; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.DeactivationCallCenter.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TOperationalProtectionType defines type OperationalProtectionType
type TOperationalProtectionType struct {
	XElemSecurityAudit
	XElemDeactivationCallCenter
	XElemsExtension
}

// Walk : if the WalkHandlers.TOperationalProtectionType function is not nil (ie. was set by outside code), calls it with this TOperationalProtectionType instance as the single argument. Then calls the Walk() method on 3/3 embed(s) and 0/0 field(s) belonging to this TOperationalProtectionType instance.
func (me *TOperationalProtectionType) Walk() (err error) {
	if fn := WalkHandlers.TOperationalProtectionType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemSecurityAudit.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemDeactivationCallCenter.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemOperationalProtection defines element OperationalProtection
type XElemOperationalProtection struct {
	//	Refers to those characteristics that describe
	//	procedural security controls employed by the Authentication Authority.
	OperationalProtection *TOperationalProtectionType `xml:"OperationalProtection"`
}

// Walk : if the WalkHandlers.XElemOperationalProtection function is not nil (ie. was set by outside code), calls it with this XElemOperationalProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemOperationalProtection instance.
func (me *XElemOperationalProtection) Walk() (err error) {
	if fn := WalkHandlers.XElemOperationalProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.OperationalProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrExternalVerificationXsdtAnyURI Refers to those characteristics that define the mechanisms by which the Principal authenticates to the Authentication Authority. The method that a Principal employs to perform authentication to local system components. This element indicates that a password (or passphrase) has been used to authenticate the Principal to a remote system.
type XAttrExternalVerificationXsdtAnyURI struct {
	ExternalVerification xsdt.AnyURI `xml:"ExternalVerification,attr,omitempty"`
}

// TPasswordType defines type PasswordType
type TPasswordType struct {
	XAttrExternalVerificationXsdtAnyURI
	XElemLength
	XElemAlphabet
	XElemGeneration
	XElemsExtension
}

// Walk : if the WalkHandlers.TPasswordType function is not nil (ie. was set by outside code), calls it with this TPasswordType instance as the single argument. Then calls the Walk() method on 4/5 embed(s) and 0/0 field(s) belonging to this TPasswordType instance.
func (me *TPasswordType) Walk() (err error) {
	if fn := WalkHandlers.TPasswordType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemAlphabet.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemGeneration.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemLength.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemPassword defines element Password
type XElemPassword struct {
	//	This element indicates that a password (or passphrase)
	//	has been used to
	//	authenticate the Principal to a remote system.
	Password *TPasswordType `xml:"Password"`
}

// Walk : if the WalkHandlers.XElemPassword function is not nil (ie. was set by outside code), calls it with this XElemPassword instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemPassword instance.
func (me *XElemPassword) Walk() (err error) {
	if fn := WalkHandlers.XElemPassword; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Password.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TxsdRestrictedLengthTypeComplexContentRestrictionMin defines type xsdRestrictedLengthTypeComplexContentRestrictionMin
type TxsdRestrictedLengthTypeComplexContentRestrictionMin xsdt.Integer

// Set : Since TxsdRestrictedLengthTypeComplexContentRestrictionMin is a non-string scalar type (either boolean or numeric), sets the current value obtained from parsing the specified string.
func (me *TxsdRestrictedLengthTypeComplexContentRestrictionMin) Set(s string) {
	(*xsdt.Integer)(me).Set(s)
}

// String : Returns a string representation of this TxsdRestrictedLengthTypeComplexContentRestrictionMin's current non-string scalar value.
func (me TxsdRestrictedLengthTypeComplexContentRestrictionMin) String() string {
	return xsdt.Integer(me).String()
}

// ToXsdtInteger : This convenience method just performs a simple type conversion to TxsdRestrictedLengthTypeComplexContentRestrictionMin's alias type xsdt.Integer.
func (me TxsdRestrictedLengthTypeComplexContentRestrictionMin) ToXsdtInteger() xsdt.Integer {
	return xsdt.Integer(me)
}

// XAttrMinTxsdRestrictedLengthTypeComplexContentRestrictionMin defines attribute MinTxsdRestrictedLengthTypeComplexContentRestrictionMin
type XAttrMinTxsdRestrictedLengthTypeComplexContentRestrictionMin struct {
	Min TxsdRestrictedLengthTypeComplexContentRestrictionMin `xml:"min,attr,omitempty"`
}

// TRestrictedLengthType defines type RestrictedLengthType
type TRestrictedLengthType struct {
	XAttrMaxXsdtInteger
	TLengthType
	XAttrMinTxsdRestrictedLengthTypeComplexContentRestrictionMin
}

// Walk : if the WalkHandlers.TRestrictedLengthType function is not nil (ie. was set by outside code), calls it with this TRestrictedLengthType instance as the single argument. Then calls the Walk() method on 1/3 embed(s) and 0/0 field(s) belonging to this TRestrictedLengthType instance.
func (me *TRestrictedLengthType) Walk() (err error) {
	if fn := WalkHandlers.TRestrictedLengthType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.TLengthType.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType defines element LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType
type XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType struct {
	Length *TRestrictedLengthType `xml:"Length"`
}

// Walk : if the WalkHandlers.XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType function is not nil (ie. was set by outside code), calls it with this XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType instance.
func (me *XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType) Walk() (err error) {
	if fn := WalkHandlers.XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Length.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TRestrictedPasswordType defines type RestrictedPasswordType
type TRestrictedPasswordType struct {
	TPasswordType
	XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType
	XElemGeneration
	XElemsExtension
	XAttrExternalVerificationXsdtAnyURI
}

// Walk : if the WalkHandlers.TRestrictedPasswordType function is not nil (ie. was set by outside code), calls it with this TRestrictedPasswordType instance as the single argument. Then calls the Walk() method on 4/5 embed(s) and 0/0 field(s) belonging to this TRestrictedPasswordType instance.
func (me *TRestrictedPasswordType) Walk() (err error) {
	if fn := WalkHandlers.TRestrictedPasswordType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.TPasswordType.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemGeneration.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemRestrictedPassword defines element RestrictedPassword
type XElemRestrictedPassword struct {
	RestrictedPassword *TRestrictedPasswordType `xml:"RestrictedPassword"`
}

// Walk : if the WalkHandlers.XElemRestrictedPassword function is not nil (ie. was set by outside code), calls it with this XElemRestrictedPassword instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemRestrictedPassword instance.
func (me *XElemRestrictedPassword) Walk() (err error) {
	if fn := WalkHandlers.XElemRestrictedPassword; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.RestrictedPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TDeviceTypeType This element indicates that a hardware or software token is used as a method of identifying the Principal. This element indicates that a time synchronization token is used to identify the Principal. hardware - the time synchonization token has been implemented in hardware. software - the time synchronization token has been implemented in software. SeedLength - the length, in bits, of the random seed used in the time synchronization token.
type TDeviceTypeType xsdt.Nmtoken

// ToXsdtNmtoken : This convenience method just performs a simple type conversion to TDeviceTypeType's alias type xsdt.Nmtoken.
func (me TDeviceTypeType) ToXsdtNmtoken() xsdt.Nmtoken { return xsdt.Nmtoken(me) }

// IsHardware : Returns true if the value of this enumerated TDeviceTypeType is "hardware".
func (me TDeviceTypeType) IsHardware() bool { return me.String() == "hardware" }

// IsSoftware : Returns true if the value of this enumerated TDeviceTypeType is "software".
func (me TDeviceTypeType) IsSoftware() bool { return me.String() == "software" }

// Set : Since TDeviceTypeType is just a simple String type, this merely sets the current value from the specified string.
func (me *TDeviceTypeType) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

// String : Since TDeviceTypeType is just a simple String type, this merely returns the current string value.
func (me TDeviceTypeType) String() string { return xsdt.Nmtoken(me).String() }

// XAttrDeviceTypeTDeviceTypeType defines attribute DeviceTypeTDeviceTypeType
type XAttrDeviceTypeTDeviceTypeType struct {
	DeviceType TDeviceTypeType `xml:"DeviceType,attr,omitempty"`
}

// XAttrSeedLengthXsdtInteger defines attribute SeedLength
type XAttrSeedLengthXsdtInteger struct {
	SeedLength xsdt.Integer `xml:"SeedLength,attr,omitempty"`
}

// TbooleanType defines type booleanType
type TbooleanType xsdt.Nmtoken

// Set : Since TbooleanType is just a simple String type, this merely sets the current value from the specified string.
func (me *TbooleanType) Set(s string) { (*xsdt.Nmtoken)(me).Set(s) }

// String : Since TbooleanType is just a simple String type, this merely returns the current string value.
func (me TbooleanType) String() string { return xsdt.Nmtoken(me).String() }

// ToXsdtNmtoken : This convenience method just performs a simple type conversion to TbooleanType's alias type xsdt.Nmtoken.
func (me TbooleanType) ToXsdtNmtoken() xsdt.Nmtoken { return xsdt.Nmtoken(me) }

// IsTrue : Returns true if the value of this enumerated TbooleanType is "true".
func (me TbooleanType) IsTrue() bool { return me.String() == "true" }

// IsFalse : Returns true if the value of this enumerated TbooleanType is "false".
func (me TbooleanType) IsFalse() bool { return me.String() == "false" }

// XAttrDeviceInHandTbooleanType defines attribute DeviceInHandTbooleanType
type XAttrDeviceInHandTbooleanType struct {
	DeviceInHand TbooleanType `xml:"DeviceInHand,attr,omitempty"`
}

// TimeSyncTokenType defines type imeSyncTokenType
type TimeSyncTokenType struct {
	XAttrDeviceInHandTbooleanType
	XAttrDeviceTypeTDeviceTypeType
	XAttrSeedLengthXsdtInteger
}

// Walk : if the WalkHandlers.TimeSyncTokenType function is not nil (ie. was set by outside code), calls it with this TimeSyncTokenType instance as the single argument. Then calls the Walk() method on 0/3 embed(s) and 0/0 field(s) belonging to this TimeSyncTokenType instance.
func (me *TimeSyncTokenType) Walk() (err error) {
	if fn := WalkHandlers.TimeSyncTokenType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemTimeSyncToken defines element TimeSyncToken
type XElemTimeSyncToken struct {
	//	This element indicates that a time synchronization
	//	token is used to identify the Principal. hardware -
	//	the time synchonization
	//	token has been implemented in hardware. software - the
	//	time synchronization
	//	token has been implemented in software. SeedLength -
	//	the length, in bits, of the
	//	random seed used in the time synchronization token.
	TimeSyncToken *TimeSyncTokenType `xml:"TimeSyncToken"`
}

// Walk : if the WalkHandlers.XElemTimeSyncToken function is not nil (ie. was set by outside code), calls it with this XElemTimeSyncToken instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemTimeSyncToken instance.
func (me *XElemTimeSyncToken) Walk() (err error) {
	if fn := WalkHandlers.XElemTimeSyncToken; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.TimeSyncToken.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TokenType defines type okenType
type TokenType struct {
	XElemTimeSyncToken
	XElemsExtension
}

// Walk : if the WalkHandlers.TokenType function is not nil (ie. was set by outside code), calls it with this TokenType instance as the single argument. Then calls the Walk() method on 2/2 embed(s) and 0/0 field(s) belonging to this TokenType instance.
func (me *TokenType) Walk() (err error) {
	if fn := WalkHandlers.TokenType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemTimeSyncToken.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemToken defines element Token
type XElemToken struct {
	//	This element indicates that a hardware or software
	//	token is used
	//	as a method of identifying the Principal.
	Token *TokenType `xml:"Token"`
}

// Walk : if the WalkHandlers.XElemToken function is not nil (ie. was set by outside code), calls it with this XElemToken instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemToken instance.
func (me *XElemToken) Walk() (err error) {
	if fn := WalkHandlers.XElemToken; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Token.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemSmartcard This element indicates that a smartcard is used to
// identity the Principal.
type XElemSmartcard struct {
	//	This element indicates that a smartcard is used to
	//	identity the Principal.
	Smartcard *TExtensionOnlyType `xml:"Smartcard"`
}

// Walk : if the WalkHandlers.XElemSmartcard function is not nil (ie. was set by outside code), calls it with this XElemSmartcard instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemSmartcard instance.
func (me *XElemSmartcard) Walk() (err error) {
	if fn := WalkHandlers.XElemSmartcard; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Smartcard.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrPreauthXsdtInteger defines attribute Preauth
type XAttrPreauthXsdtInteger struct {
	Preauth xsdt.Integer `xml:"preauth,attr,omitempty"`
}

// TPrincipalAuthenticationMechanismType defines type PrincipalAuthenticationMechanismType
type TPrincipalAuthenticationMechanismType struct {
	XElemSmartcard
	XElemActivationPin
	XElemsExtension
	XAttrPreauthXsdtInteger
	XElemPassword
	XElemRestrictedPassword
	XElemToken
}

// Walk : if the WalkHandlers.TPrincipalAuthenticationMechanismType function is not nil (ie. was set by outside code), calls it with this TPrincipalAuthenticationMechanismType instance as the single argument. Then calls the Walk() method on 6/7 embed(s) and 0/0 field(s) belonging to this TPrincipalAuthenticationMechanismType instance.
func (me *TPrincipalAuthenticationMechanismType) Walk() (err error) {
	if fn := WalkHandlers.TPrincipalAuthenticationMechanismType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemRestrictedPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemToken.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemSmartcard.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemActivationPin.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemPrincipalAuthenticationMechanism defines element PrincipalAuthenticationMechanism
type XElemPrincipalAuthenticationMechanism struct {
	//	The method that a Principal employs to perform
	//	authentication to local system components.
	PrincipalAuthenticationMechanism *TPrincipalAuthenticationMechanismType `xml:"PrincipalAuthenticationMechanism"`
}

// Walk : if the WalkHandlers.XElemPrincipalAuthenticationMechanism function is not nil (ie. was set by outside code), calls it with this XElemPrincipalAuthenticationMechanism instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemPrincipalAuthenticationMechanism instance.
func (me *XElemPrincipalAuthenticationMechanism) Walk() (err error) {
	if fn := WalkHandlers.XElemPrincipalAuthenticationMechanism; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.PrincipalAuthenticationMechanism.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrKeyValidationXsdtString The method applied to validate a principal's
// authentication across a network
// The local system has a private key but it is used
// in decryption mode, rather than signature mode. For example, the
// Authentication Authority generates a secret and encrypts it using the
// local system's public key: the local system then proves it has
// decrypted the secret.
type XAttrKeyValidationXsdtString struct {
	KeyValidation xsdt.String `xml:"keyValidation,attr,omitempty"`
}

// TPublicKeyType defines type PublicKeyType
type TPublicKeyType struct {
	XElemsExtension
	XAttrKeyValidationXsdtString
}

// Walk : if the WalkHandlers.TPublicKeyType function is not nil (ie. was set by outside code), calls it with this TPublicKeyType instance as the single argument. Then calls the Walk() method on 1/2 embed(s) and 0/0 field(s) belonging to this TPublicKeyType instance.
func (me *TPublicKeyType) Walk() (err error) {
	if fn := WalkHandlers.TPublicKeyType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemAsymmetricDecryption defines element AsymmetricDecryption
type XElemAsymmetricDecryption struct {
	//	The local system has a private key but it is used
	//	in decryption mode, rather than signature mode. For example, the
	//	Authentication Authority generates a secret and encrypts it using the
	//	local system's public key: the local system then proves it has
	//	decrypted the secret.
	AsymmetricDecryption *TPublicKeyType `xml:"AsymmetricDecryption"`
}

// Walk : if the WalkHandlers.XElemAsymmetricDecryption function is not nil (ie. was set by outside code), calls it with this XElemAsymmetricDecryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemAsymmetricDecryption instance.
func (me *XElemAsymmetricDecryption) Walk() (err error) {
	if fn := WalkHandlers.XElemAsymmetricDecryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.AsymmetricDecryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemSubscriberLineNumber defines element SubscriberLineNumber
type XElemSubscriberLineNumber struct {
	SubscriberLineNumber *TExtensionOnlyType `xml:"SubscriberLineNumber"`
}

// Walk : if the WalkHandlers.XElemSubscriberLineNumber function is not nil (ie. was set by outside code), calls it with this XElemSubscriberLineNumber instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemSubscriberLineNumber instance.
func (me *XElemSubscriberLineNumber) Walk() (err error) {
	if fn := WalkHandlers.XElemSubscriberLineNumber; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SubscriberLineNumber.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemResumeSession Supports Authenticators with nested combinations of
// additional complexity.
// Rather like PreviousSession but using stronger
// security. A secret that was established in a previous session with
// the Authentication Authority has been cached by the local system and
// is now re-used (e.g. a Master Secret is used to derive new session
// keys in TLS, SSL, WTLS).
type XElemResumeSession struct {
	//	Rather like PreviousSession but using stronger
	//	security. A secret that was established in a previous session with
	//	the Authentication Authority has been cached by the local system and
	//	is now re-used (e.g. a Master Secret is used to derive new session
	//	keys in TLS, SSL, WTLS).
	ResumeSession *TExtensionOnlyType `xml:"ResumeSession"`
}

// Walk : if the WalkHandlers.XElemResumeSession function is not nil (ie. was set by outside code), calls it with this XElemResumeSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemResumeSession instance.
func (me *XElemResumeSession) Walk() (err error) {
	if fn := WalkHandlers.XElemResumeSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ResumeSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrMethodXsdtAnyURI This element indicates that the Principal has been
// authenticated by a challenge-response protocol utilizing shared secret
// keys and symmetric cryptography.
type XAttrMethodXsdtAnyURI struct {
	Method xsdt.AnyURI `xml:"method,attr,omitempty"`
}

// TSharedSecretChallengeResponseType defines type SharedSecretChallengeResponseType
type TSharedSecretChallengeResponseType struct {
	XElemsExtension
	XAttrMethodXsdtAnyURI
}

// Walk : if the WalkHandlers.TSharedSecretChallengeResponseType function is not nil (ie. was set by outside code), calls it with this TSharedSecretChallengeResponseType instance as the single argument. Then calls the Walk() method on 1/2 embed(s) and 0/0 field(s) belonging to this TSharedSecretChallengeResponseType instance.
func (me *TSharedSecretChallengeResponseType) Walk() (err error) {
	if fn := WalkHandlers.TSharedSecretChallengeResponseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemSharedSecretChallengeResponse defines element SharedSecretChallengeResponse
type XElemSharedSecretChallengeResponse struct {
	SharedSecretChallengeResponse *TSharedSecretChallengeResponseType `xml:"SharedSecretChallengeResponse"`
}

// Walk : if the WalkHandlers.XElemSharedSecretChallengeResponse function is not nil (ie. was set by outside code), calls it with this XElemSharedSecretChallengeResponse instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemSharedSecretChallengeResponse instance.
func (me *XElemSharedSecretChallengeResponse) Walk() (err error) {
	if fn := WalkHandlers.XElemSharedSecretChallengeResponse; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SharedSecretChallengeResponse.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemIPAddress This element indicates that the Principal has been
// authenticated through connection from a particular IP address.
type XElemIPAddress struct {
	//	This element indicates that the Principal has been
	//	authenticated through connection from a particular IP address.
	IPAddress *TExtensionOnlyType `xml:"IPAddress"`
}

// Walk : if the WalkHandlers.XElemIPAddress function is not nil (ie. was set by outside code), calls it with this XElemIPAddress instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemIPAddress instance.
func (me *XElemIPAddress) Walk() (err error) {
	if fn := WalkHandlers.XElemIPAddress; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.IPAddress.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemAsymmetricKeyAgreement The local system has a private key and uses it for
// shared secret key agreement with the Authentication Authority (e.g.
// via Diffie Helman).
type XElemAsymmetricKeyAgreement struct {
	//	The local system has a private key and uses it for
	//	shared secret key agreement with the Authentication Authority (e.g.
	//	via Diffie Helman).
	AsymmetricKeyAgreement *TPublicKeyType `xml:"AsymmetricKeyAgreement"`
}

// Walk : if the WalkHandlers.XElemAsymmetricKeyAgreement function is not nil (ie. was set by outside code), calls it with this XElemAsymmetricKeyAgreement instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemAsymmetricKeyAgreement instance.
func (me *XElemAsymmetricKeyAgreement) Walk() (err error) {
	if fn := WalkHandlers.XElemAsymmetricKeyAgreement; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.AsymmetricKeyAgreement.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemPreviousSession Indicates that the Principal has been strongly
// authenticated in a previous session during which the IdP has set a
// cookie in the UA. During the present session the Principal has only
// been authenticated by the UA returning the cookie to the IdP.
type XElemPreviousSession struct {
	//	Indicates that the Principal has been strongly
	//	authenticated in a previous session during which the IdP has set a
	//	cookie in the UA. During the present session the Principal has only
	//	been authenticated by the UA returning the cookie to the IdP.
	PreviousSession *TExtensionOnlyType `xml:"PreviousSession"`
}

// Walk : if the WalkHandlers.XElemPreviousSession function is not nil (ie. was set by outside code), calls it with this XElemPreviousSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemPreviousSession instance.
func (me *XElemPreviousSession) Walk() (err error) {
	if fn := WalkHandlers.XElemPreviousSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.PreviousSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemSharedSecretDynamicPlaintext The local system and Authentication Authority
// share a secret key. The local system uses this to encrypt a
// randomised string to pass to the Authentication Authority.
type XElemSharedSecretDynamicPlaintext struct {
	//	The local system and Authentication Authority
	//	share a secret key. The local system uses this to encrypt a
	//	randomised string to pass to the Authentication Authority.
	SharedSecretDynamicPlaintext *TExtensionOnlyType `xml:"SharedSecretDynamicPlaintext"`
}

// Walk : if the WalkHandlers.XElemSharedSecretDynamicPlaintext function is not nil (ie. was set by outside code), calls it with this XElemSharedSecretDynamicPlaintext instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemSharedSecretDynamicPlaintext instance.
func (me *XElemSharedSecretDynamicPlaintext) Walk() (err error) {
	if fn := WalkHandlers.XElemSharedSecretDynamicPlaintext; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.SharedSecretDynamicPlaintext.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemUserSuffix defines element UserSuffix
type XElemUserSuffix struct {
	UserSuffix *TExtensionOnlyType `xml:"UserSuffix"`
}

// Walk : if the WalkHandlers.XElemUserSuffix function is not nil (ie. was set by outside code), calls it with this XElemUserSuffix instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemUserSuffix instance.
func (me *XElemUserSuffix) Walk() (err error) {
	if fn := WalkHandlers.XElemUserSuffix; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.UserSuffix.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemDigSig This element indicates that the Principal has been
// authenticated by a mechanism which involves the Principal computing a
// digital signature over at least challenge data provided by the IdP.
type XElemDigSig struct {
	//	This element indicates that the Principal has been
	//	authenticated by a mechanism which involves the Principal computing a
	//	digital signature over at least challenge data provided by the IdP.
	DigSig *TPublicKeyType `xml:"DigSig"`
}

// Walk : if the WalkHandlers.XElemDigSig function is not nil (ie. was set by outside code), calls it with this XElemDigSig instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemDigSig instance.
func (me *XElemDigSig) Walk() (err error) {
	if fn := WalkHandlers.XElemDigSig; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.DigSig.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemZeroKnowledge This element indicates that the Principal has been
// authenticated by a zero knowledge technique as specified in ISO/IEC
// 9798-5.
type XElemZeroKnowledge struct {
	//	This element indicates that the Principal has been
	//	authenticated by a zero knowledge technique as specified in ISO/IEC
	//	9798-5.
	ZeroKnowledge *TExtensionOnlyType `xml:"ZeroKnowledge"`
}

// Walk : if the WalkHandlers.XElemZeroKnowledge function is not nil (ie. was set by outside code), calls it with this XElemZeroKnowledge instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemZeroKnowledge instance.
func (me *XElemZeroKnowledge) Walk() (err error) {
	if fn := WalkHandlers.XElemZeroKnowledge; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ZeroKnowledge.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XGroupAuthenticatorSequenceGroup defines XGroupAuthenticatorSequenceGroup
type XGroupAuthenticatorSequenceGroup struct {
	XElemPreviousSession
	XElemRestrictedPassword
	XElemSharedSecretDynamicPlaintext
	XElemUserSuffix
	XElemDigSig
	XElemZeroKnowledge
	XElemsExtension
	XElemSubscriberLineNumber
	XElemResumeSession
	XElemPassword
	XElemSharedSecretChallengeResponse
	XElemIPAddress
	XElemAsymmetricDecryption
	XElemAsymmetricKeyAgreement
}

// Walk : if the WalkHandlers.XGroupAuthenticatorSequenceGroup function is not nil (ie. was set by outside code), calls it with this XGroupAuthenticatorSequenceGroup instance as the single argument. Then calls the Walk() method on 14/14 embed(s) and 0/0 field(s) belonging to this XGroupAuthenticatorSequenceGroup instance.
func (me *XGroupAuthenticatorSequenceGroup) Walk() (err error) {
	if fn := WalkHandlers.XGroupAuthenticatorSequenceGroup; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemAsymmetricDecryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemAsymmetricKeyAgreement.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemPreviousSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemRestrictedPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemSharedSecretDynamicPlaintext.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemUserSuffix.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemDigSig.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemZeroKnowledge.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemResumeSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemSharedSecretChallengeResponse.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemIPAddress.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemSubscriberLineNumber.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TComplexAuthenticatorType defines type ComplexAuthenticatorType
type TComplexAuthenticatorType struct {
	XGroupAuthenticatorChoiceGroup
	XGroupAuthenticatorSequenceGroup
}

// Walk : if the WalkHandlers.TComplexAuthenticatorType function is not nil (ie. was set by outside code), calls it with this TComplexAuthenticatorType instance as the single argument. Then calls the Walk() method on 1/2 embed(s) and 0/0 field(s) belonging to this TComplexAuthenticatorType instance.
func (me *TComplexAuthenticatorType) Walk() (err error) {
	if fn := WalkHandlers.TComplexAuthenticatorType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XGroupAuthenticatorSequenceGroup.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemComplexAuthenticator defines element ComplexAuthenticator
type XElemComplexAuthenticator struct {
	//	Supports Authenticators with nested combinations of
	//	additional complexity.
	ComplexAuthenticator *TComplexAuthenticatorType `xml:"ComplexAuthenticator"`
}

// Walk : if the WalkHandlers.XElemComplexAuthenticator function is not nil (ie. was set by outside code), calls it with this XElemComplexAuthenticator instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemComplexAuthenticator instance.
func (me *XElemComplexAuthenticator) Walk() (err error) {
	if fn := WalkHandlers.XElemComplexAuthenticator; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.ComplexAuthenticator.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XGroupAuthenticatorChoiceGroup defines XGroupAuthenticatorChoiceGroup
type XGroupAuthenticatorChoiceGroup struct {
	XElemZeroKnowledge
	XElemSharedSecretChallengeResponse
	XElemIPAddress
	XElemAsymmetricKeyAgreement
	XElemUserSuffix
	XElemDigSig
	XElemResumeSession
	XElemAsymmetricDecryption
	XElemSubscriberLineNumber
	XElemComplexAuthenticator
	XElemPreviousSession
	XElemRestrictedPassword
	XElemSharedSecretDynamicPlaintext
	XElemPassword
}

// Walk : if the WalkHandlers.XGroupAuthenticatorChoiceGroup function is not nil (ie. was set by outside code), calls it with this XGroupAuthenticatorChoiceGroup instance as the single argument. Then calls the Walk() method on 14/14 embed(s) and 0/0 field(s) belonging to this XGroupAuthenticatorChoiceGroup instance.
func (me *XGroupAuthenticatorChoiceGroup) Walk() (err error) {
	if fn := WalkHandlers.XGroupAuthenticatorChoiceGroup; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemComplexAuthenticator.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemPreviousSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemResumeSession.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemAsymmetricDecryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemSubscriberLineNumber.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemRestrictedPassword.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemSharedSecretDynamicPlaintext.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemAsymmetricKeyAgreement.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemUserSuffix.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemDigSig.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemZeroKnowledge.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemSharedSecretChallengeResponse.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemIPAddress.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TAuthenticatorBaseType defines type AuthenticatorBaseType
type TAuthenticatorBaseType struct {
	XGroupAuthenticatorSequenceGroup
	XGroupAuthenticatorChoiceGroup
}

// Walk : if the WalkHandlers.TAuthenticatorBaseType function is not nil (ie. was set by outside code), calls it with this TAuthenticatorBaseType instance as the single argument. Then calls the Walk() method on 2/2 embed(s) and 0/0 field(s) belonging to this TAuthenticatorBaseType instance.
func (me *TAuthenticatorBaseType) Walk() (err error) {
	if fn := WalkHandlers.TAuthenticatorBaseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XGroupAuthenticatorChoiceGroup.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XGroupAuthenticatorSequenceGroup.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemAuthenticator defines element Authenticator
type XElemAuthenticator struct {
	//	The method applied to validate a principal's
	//	authentication across a network
	Authenticator *TAuthenticatorBaseType `xml:"Authenticator"`
}

// Walk : if the WalkHandlers.XElemAuthenticator function is not nil (ie. was set by outside code), calls it with this XElemAuthenticator instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemAuthenticator instance.
func (me *XElemAuthenticator) Walk() (err error) {
	if fn := WalkHandlers.XElemAuthenticator; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Authenticator.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemSsl The protocol across which Authenticator information is
// transferred to an Authentication Authority verifier.
// This element indicates that the Authenticator has been
// transmitted using a transport mechnanism protected by an SSL or TLS
// session.
type XElemSsl struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechnanism protected by an SSL or TLS
	//	session.
	Ssl *TExtensionOnlyType `xml:"SSL"`
}

// Walk : if the WalkHandlers.XElemSsl function is not nil (ie. was set by outside code), calls it with this XElemSsl instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemSsl instance.
func (me *XElemSsl) Walk() (err error) {
	if fn := WalkHandlers.XElemSsl; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Ssl.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemMobileNetworkRadioEncryption defines element MobileNetworkRadioEncryption
type XElemMobileNetworkRadioEncryption struct {
	MobileNetworkRadioEncryption *TExtensionOnlyType `xml:"MobileNetworkRadioEncryption"`
}

// Walk : if the WalkHandlers.XElemMobileNetworkRadioEncryption function is not nil (ie. was set by outside code), calls it with this XElemMobileNetworkRadioEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemMobileNetworkRadioEncryption instance.
func (me *XElemMobileNetworkRadioEncryption) Walk() (err error) {
	if fn := WalkHandlers.XElemMobileNetworkRadioEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.MobileNetworkRadioEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemMobileNetworkEndToEndEncryption defines element MobileNetworkEndToEndEncryption
type XElemMobileNetworkEndToEndEncryption struct {
	MobileNetworkEndToEndEncryption *TExtensionOnlyType `xml:"MobileNetworkEndToEndEncryption"`
}

// Walk : if the WalkHandlers.XElemMobileNetworkEndToEndEncryption function is not nil (ie. was set by outside code), calls it with this XElemMobileNetworkEndToEndEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemMobileNetworkEndToEndEncryption instance.
func (me *XElemMobileNetworkEndToEndEncryption) Walk() (err error) {
	if fn := WalkHandlers.XElemMobileNetworkEndToEndEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.MobileNetworkEndToEndEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemIPSec This element indicates that the Authenticator has been
// transmitted using a transport mechanism protected by an IPSEC session.
type XElemIPSec struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechanism protected by an IPSEC session.
	IPSec *TExtensionOnlyType `xml:"IPSec"`
}

// Walk : if the WalkHandlers.XElemIPSec function is not nil (ie. was set by outside code), calls it with this XElemIPSec instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemIPSec instance.
func (me *XElemIPSec) Walk() (err error) {
	if fn := WalkHandlers.XElemIPSec; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.IPSec.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemPstn defines element Pstn
type XElemPstn struct {
	Pstn *TExtensionOnlyType `xml:"PSTN"`
}

// Walk : if the WalkHandlers.XElemPstn function is not nil (ie. was set by outside code), calls it with this XElemPstn instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemPstn instance.
func (me *XElemPstn) Walk() (err error) {
	if fn := WalkHandlers.XElemPstn; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Pstn.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemHTTP This element indicates that the Authenticator has been
// transmitted using bare HTTP utilizing no additional security
// protocols.
type XElemHTTP struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using bare HTTP utilizing no additional security
	//	protocols.
	HTTP *TExtensionOnlyType `xml:"HTTP"`
}

// Walk : if the WalkHandlers.XElemHTTP function is not nil (ie. was set by outside code), calls it with this XElemHTTP instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemHTTP instance.
func (me *XElemHTTP) Walk() (err error) {
	if fn := WalkHandlers.XElemHTTP; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.HTTP.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemMobileNetworkNoEncryption This element indicates that the Authenticator has been
// transmitted solely across a mobile network using no additional
// security mechanism.
type XElemMobileNetworkNoEncryption struct {
	//	This element indicates that the Authenticator has been
	//	transmitted solely across a mobile network using no additional
	//	security mechanism.
	MobileNetworkNoEncryption *TExtensionOnlyType `xml:"MobileNetworkNoEncryption"`
}

// Walk : if the WalkHandlers.XElemMobileNetworkNoEncryption function is not nil (ie. was set by outside code), calls it with this XElemMobileNetworkNoEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemMobileNetworkNoEncryption instance.
func (me *XElemMobileNetworkNoEncryption) Walk() (err error) {
	if fn := WalkHandlers.XElemMobileNetworkNoEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.MobileNetworkNoEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemWtls This element indicates that the Authenticator has been
// transmitted using a transport mechanism protected by a WTLS session.
type XElemWtls struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechanism protected by a WTLS session.
	Wtls *TExtensionOnlyType `xml:"WTLS"`
}

// Walk : if the WalkHandlers.XElemWtls function is not nil (ie. was set by outside code), calls it with this XElemWtls instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemWtls instance.
func (me *XElemWtls) Walk() (err error) {
	if fn := WalkHandlers.XElemWtls; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Wtls.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemIsdn defines element Isdn
type XElemIsdn struct {
	Isdn *TExtensionOnlyType `xml:"ISDN"`
}

// Walk : if the WalkHandlers.XElemIsdn function is not nil (ie. was set by outside code), calls it with this XElemIsdn instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemIsdn instance.
func (me *XElemIsdn) Walk() (err error) {
	if fn := WalkHandlers.XElemIsdn; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Isdn.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemAdsl defines element Adsl
type XElemAdsl struct {
	Adsl *TExtensionOnlyType `xml:"ADSL"`
}

// Walk : if the WalkHandlers.XElemAdsl function is not nil (ie. was set by outside code), calls it with this XElemAdsl instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemAdsl instance.
func (me *XElemAdsl) Walk() (err error) {
	if fn := WalkHandlers.XElemAdsl; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Adsl.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TAuthenticatorTransportProtocolType defines type AuthenticatorTransportProtocolType
type TAuthenticatorTransportProtocolType struct {
	XElemSsl
	XElemMobileNetworkRadioEncryption
	XElemMobileNetworkEndToEndEncryption
	XElemIPSec
	XElemPstn
	XElemHTTP
	XElemMobileNetworkNoEncryption
	XElemWtls
	XElemIsdn
	XElemAdsl
	XElemsExtension
}

// Walk : if the WalkHandlers.TAuthenticatorTransportProtocolType function is not nil (ie. was set by outside code), calls it with this TAuthenticatorTransportProtocolType instance as the single argument. Then calls the Walk() method on 11/11 embed(s) and 0/0 field(s) belonging to this TAuthenticatorTransportProtocolType instance.
func (me *TAuthenticatorTransportProtocolType) Walk() (err error) {
	if fn := WalkHandlers.TAuthenticatorTransportProtocolType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemMobileNetworkEndToEndEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemIPSec.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemPstn.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemSsl.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemMobileNetworkRadioEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemWtls.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemIsdn.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemAdsl.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemHTTP.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemMobileNetworkNoEncryption.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemAuthenticatorTransportProtocol defines element AuthenticatorTransportProtocol
type XElemAuthenticatorTransportProtocol struct {
	//	The protocol across which Authenticator information is
	//	transferred to an Authentication Authority verifier.
	AuthenticatorTransportProtocol *TAuthenticatorTransportProtocolType `xml:"AuthenticatorTransportProtocol"`
}

// Walk : if the WalkHandlers.XElemAuthenticatorTransportProtocol function is not nil (ie. was set by outside code), calls it with this XElemAuthenticatorTransportProtocol instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemAuthenticatorTransportProtocol instance.
func (me *XElemAuthenticatorTransportProtocol) Walk() (err error) {
	if fn := WalkHandlers.XElemAuthenticatorTransportProtocol; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.AuthenticatorTransportProtocol.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TAuthnMethodBaseType defines type AuthnMethodBaseType
type TAuthnMethodBaseType struct {
	XElemPrincipalAuthenticationMechanism
	XElemAuthenticator
	XElemAuthenticatorTransportProtocol
	XElemsExtension
}

// Walk : if the WalkHandlers.TAuthnMethodBaseType function is not nil (ie. was set by outside code), calls it with this TAuthnMethodBaseType instance as the single argument. Then calls the Walk() method on 4/4 embed(s) and 0/0 field(s) belonging to this TAuthnMethodBaseType instance.
func (me *TAuthnMethodBaseType) Walk() (err error) {
	if fn := WalkHandlers.TAuthnMethodBaseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemPrincipalAuthenticationMechanism.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemAuthenticator.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemAuthenticatorTransportProtocol.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemAuthnMethod defines element AuthnMethod
type XElemAuthnMethod struct {
	//	Refers to those characteristics that define the
	//	mechanisms by which the Principal authenticates to the Authentication
	//	Authority.
	AuthnMethod *TAuthnMethodBaseType `xml:"AuthnMethod"`
}

// Walk : if the WalkHandlers.XElemAuthnMethod function is not nil (ie. was set by outside code), calls it with this XElemAuthnMethod instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemAuthnMethod instance.
func (me *XElemAuthnMethod) Walk() (err error) {
	if fn := WalkHandlers.XElemAuthnMethod; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.AuthnMethod.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TAuthnContextDeclarationBaseType defines type AuthnContextDeclarationBaseType
type TAuthnContextDeclarationBaseType struct {
	XElemIdentification
	XElemTechnicalProtection
	XElemOperationalProtection
	XElemAuthnMethod
	XElemGoverningAgreements
	XElemsExtension
	XAttrIDXsdtID
}

// Walk : if the WalkHandlers.TAuthnContextDeclarationBaseType function is not nil (ie. was set by outside code), calls it with this TAuthnContextDeclarationBaseType instance as the single argument. Then calls the Walk() method on 6/7 embed(s) and 0/0 field(s) belonging to this TAuthnContextDeclarationBaseType instance.
func (me *TAuthnContextDeclarationBaseType) Walk() (err error) {
	if fn := WalkHandlers.TAuthnContextDeclarationBaseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.XElemsExtension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemIdentification.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemTechnicalProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemOperationalProtection.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemAuthnMethod.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if err = me.XElemGoverningAgreements.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemAuthenticationContextDeclaration defines element AuthenticationContextDeclaration
type XElemAuthenticationContextDeclaration struct {
	//	A particular assertion on an identity
	//	provider's part with respect to the authentication
	//	context associated with an authentication assertion.
	AuthenticationContextDeclaration *TAuthnContextDeclarationBaseType `xml:"AuthenticationContextDeclaration"`
}

// Walk : if the WalkHandlers.XElemAuthenticationContextDeclaration function is not nil (ie. was set by outside code), calls it with this XElemAuthenticationContextDeclaration instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemAuthenticationContextDeclaration instance.
func (me *XElemAuthenticationContextDeclaration) Walk() (err error) {
	if fn := WalkHandlers.XElemAuthenticationContextDeclaration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.AuthenticationContextDeclaration.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsAuthenticationContextDeclaration A particular assertion on an identity
// provider's part with respect to the authentication
// context associated with an authentication assertion.
type XElemsAuthenticationContextDeclaration struct {
	//	A particular assertion on an identity
	//	provider's part with respect to the authentication
	//	context associated with an authentication assertion.
	AuthenticationContextDeclarations []*TAuthnContextDeclarationBaseType `xml:"AuthenticationContextDeclaration"`
}

// Walk : if the WalkHandlers.XElemsAuthenticationContextDeclaration function is not nil (ie. was set by outside code), calls it with this XElemsAuthenticationContextDeclaration instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsAuthenticationContextDeclaration instance.
func (me *XElemsAuthenticationContextDeclaration) Walk() (err error) {
	if fn := WalkHandlers.XElemsAuthenticationContextDeclaration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.AuthenticationContextDeclarations {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsIdentification Refers to those characteristics that describe the
// processes and mechanisms
// the Authentication Authority uses to initially create
// an association between a Principal
// and the identity (or name) by which the Principal will
// be known
type XElemsIdentification struct {
	//	Refers to those characteristics that describe the
	//	processes and mechanisms
	//	the Authentication Authority uses to initially create
	//	an association between a Principal
	//	and the identity (or name) by which the Principal will
	//	be known
	Identifications []*TIdentificationType `xml:"Identification"`
}

// Walk : if the WalkHandlers.XElemsIdentification function is not nil (ie. was set by outside code), calls it with this XElemsIdentification instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsIdentification instance.
func (me *XElemsIdentification) Walk() (err error) {
	if fn := WalkHandlers.XElemsIdentification; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Identifications {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsPhysicalVerification This element indicates that identification has been
// performed in a physical
// face-to-face meeting with the principal and not in an
// online manner.
type XElemsPhysicalVerification struct {
	//	This element indicates that identification has been
	//	performed in a physical
	//	face-to-face meeting with the principal and not in an
	//	online manner.
	PhysicalVerifications []*TxsdPhysicalVerification `xml:"PhysicalVerification"`
}

// Walk : if the WalkHandlers.XElemsPhysicalVerification function is not nil (ie. was set by outside code), calls it with this XElemsPhysicalVerification instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsPhysicalVerification instance.
func (me *XElemsPhysicalVerification) Walk() (err error) {
	if fn := WalkHandlers.XElemsPhysicalVerification; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.PhysicalVerifications {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsWrittenConsent defines element WrittenConsent
type XElemsWrittenConsent struct {
	WrittenConsents []*TExtensionOnlyType `xml:"WrittenConsent"`
}

// Walk : if the WalkHandlers.XElemsWrittenConsent function is not nil (ie. was set by outside code), calls it with this XElemsWrittenConsent instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsWrittenConsent instance.
func (me *XElemsWrittenConsent) Walk() (err error) {
	if fn := WalkHandlers.XElemsWrittenConsent; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.WrittenConsents {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsTechnicalProtection Refers to those characterstics that describe how the
// 'secret' (the knowledge or possession
// of which allows the Principal to authenticate to the
// Authentication Authority) is kept secure
type XElemsTechnicalProtection struct {
	//	Refers to those characterstics that describe how the
	//	'secret' (the knowledge or possession
	//	of which allows the Principal to authenticate to the
	//	Authentication Authority) is kept secure
	TechnicalProtections []*TechnicalProtectionBaseType `xml:"TechnicalProtection"`
}

// Walk : if the WalkHandlers.XElemsTechnicalProtection function is not nil (ie. was set by outside code), calls it with this XElemsTechnicalProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsTechnicalProtection instance.
func (me *XElemsTechnicalProtection) Walk() (err error) {
	if fn := WalkHandlers.XElemsTechnicalProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.TechnicalProtections {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsSecretKeyProtection This element indicates the types and strengths of
// facilities
// of a UA used to protect a shared secret key from
// unauthorized access and/or use.
type XElemsSecretKeyProtection struct {
	//	This element indicates the types and strengths of
	//	facilities
	//	of a UA used to protect a shared secret key from
	//	unauthorized access and/or use.
	SecretKeyProtections []*TSecretKeyProtectionType `xml:"SecretKeyProtection"`
}

// Walk : if the WalkHandlers.XElemsSecretKeyProtection function is not nil (ie. was set by outside code), calls it with this XElemsSecretKeyProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsSecretKeyProtection instance.
func (me *XElemsSecretKeyProtection) Walk() (err error) {
	if fn := WalkHandlers.XElemsSecretKeyProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SecretKeyProtections {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsPrivateKeyProtection This element indicates the types and strengths of
// facilities
// of a UA used to protect a private key from
// unauthorized access and/or use.
type XElemsPrivateKeyProtection struct {
	//	This element indicates the types and strengths of
	//	facilities
	//	of a UA used to protect a private key from
	//	unauthorized access and/or use.
	PrivateKeyProtections []*TPrivateKeyProtectionType `xml:"PrivateKeyProtection"`
}

// Walk : if the WalkHandlers.XElemsPrivateKeyProtection function is not nil (ie. was set by outside code), calls it with this XElemsPrivateKeyProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsPrivateKeyProtection instance.
func (me *XElemsPrivateKeyProtection) Walk() (err error) {
	if fn := WalkHandlers.XElemsPrivateKeyProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.PrivateKeyProtections {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsKeyActivation The actions that must be performed
// before the private key can be used.
type XElemsKeyActivation struct {
	//	The actions that must be performed
	//	before the private key can be used.
	KeyActivations []*TKeyActivationType `xml:"KeyActivation"`
}

// Walk : if the WalkHandlers.XElemsKeyActivation function is not nil (ie. was set by outside code), calls it with this XElemsKeyActivation instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsKeyActivation instance.
func (me *XElemsKeyActivation) Walk() (err error) {
	if fn := WalkHandlers.XElemsKeyActivation; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.KeyActivations {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsKeySharing Whether or not the private key is shared
// with the certificate authority.
type XElemsKeySharing struct {
	//	Whether or not the private key is shared
	//	with the certificate authority.
	KeySharings []*TKeySharingType `xml:"KeySharing"`
}

// Walk : if the WalkHandlers.XElemsKeySharing function is not nil (ie. was set by outside code), calls it with this XElemsKeySharing instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsKeySharing instance.
func (me *XElemsKeySharing) Walk() (err error) {
	if fn := WalkHandlers.XElemsKeySharing; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.KeySharings {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsKeyStorage In which medium is the key stored.
// memory - the key is stored in memory.
// smartcard - the key is stored in a smartcard.
// token - the key is stored in a hardware token.
// MobileDevice - the key is stored in a mobile device.
// MobileAuthCard - the key is stored in a mobile
// authentication card.
type XElemsKeyStorage struct {
	//	In which medium is the key stored.
	//	memory - the key is stored in memory.
	//	smartcard - the key is stored in a smartcard.
	//	token - the key is stored in a hardware token.
	//	MobileDevice - the key is stored in a mobile device.
	//	MobileAuthCard - the key is stored in a mobile
	//	authentication card.
	KeyStorages []*TKeyStorageType `xml:"KeyStorage"`
}

// Walk : if the WalkHandlers.XElemsKeyStorage function is not nil (ie. was set by outside code), calls it with this XElemsKeyStorage instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsKeyStorage instance.
func (me *XElemsKeyStorage) Walk() (err error) {
	if fn := WalkHandlers.XElemsKeyStorage; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.KeyStorages {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsSubscriberLineNumber defines element SubscriberLineNumber
type XElemsSubscriberLineNumber struct {
	SubscriberLineNumbers []*TExtensionOnlyType `xml:"SubscriberLineNumber"`
}

// Walk : if the WalkHandlers.XElemsSubscriberLineNumber function is not nil (ie. was set by outside code), calls it with this XElemsSubscriberLineNumber instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsSubscriberLineNumber instance.
func (me *XElemsSubscriberLineNumber) Walk() (err error) {
	if fn := WalkHandlers.XElemsSubscriberLineNumber; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SubscriberLineNumbers {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsUserSuffix defines element UserSuffix
type XElemsUserSuffix struct {
	UserSuffixs []*TExtensionOnlyType `xml:"UserSuffix"`
}

// Walk : if the WalkHandlers.XElemsUserSuffix function is not nil (ie. was set by outside code), calls it with this XElemsUserSuffix instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsUserSuffix instance.
func (me *XElemsUserSuffix) Walk() (err error) {
	if fn := WalkHandlers.XElemsUserSuffix; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.UserSuffixs {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsPassword This element indicates that a password (or passphrase)
// has been used to
// authenticate the Principal to a remote system.
type XElemsPassword struct {
	//	This element indicates that a password (or passphrase)
	//	has been used to
	//	authenticate the Principal to a remote system.
	Passwords []*TPasswordType `xml:"Password"`
}

// Walk : if the WalkHandlers.XElemsPassword function is not nil (ie. was set by outside code), calls it with this XElemsPassword instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsPassword instance.
func (me *XElemsPassword) Walk() (err error) {
	if fn := WalkHandlers.XElemsPassword; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Passwords {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsActivationPin This element indicates that a Pin (Personal
// Identification Number) has been used to authenticate the Principal to
// some local system in order to activate a key.
type XElemsActivationPin struct {
	//	This element indicates that a Pin (Personal
	//	Identification Number) has been used to authenticate the Principal to
	//	some local system in order to activate a key.
	ActivationPins []*TActivationPinType `xml:"ActivationPin"`
}

// Walk : if the WalkHandlers.XElemsActivationPin function is not nil (ie. was set by outside code), calls it with this XElemsActivationPin instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsActivationPin instance.
func (me *XElemsActivationPin) Walk() (err error) {
	if fn := WalkHandlers.XElemsActivationPin; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ActivationPins {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsToken This element indicates that a hardware or software
// token is used
// as a method of identifying the Principal.
type XElemsToken struct {
	//	This element indicates that a hardware or software
	//	token is used
	//	as a method of identifying the Principal.
	Tokens []*TokenType `xml:"Token"`
}

// Walk : if the WalkHandlers.XElemsToken function is not nil (ie. was set by outside code), calls it with this XElemsToken instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsToken instance.
func (me *XElemsToken) Walk() (err error) {
	if fn := WalkHandlers.XElemsToken; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Tokens {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsTimeSyncToken This element indicates that a time synchronization token is used to identify the Principal. hardware - the time synchonization token has been implemented in hardware. software - the time synchronization token has been implemented in software. SeedLength - the length, in bits, of the random seed used in the time synchronization token.
type XElemsTimeSyncToken struct {
	//	This element indicates that a time synchronization
	//	token is used to identify the Principal. hardware -
	//	the time synchonization
	//	token has been implemented in hardware. software - the
	//	time synchronization
	//	token has been implemented in software. SeedLength -
	//	the length, in bits, of the
	//	random seed used in the time synchronization token.
	TimeSyncTokens []*TimeSyncTokenType `xml:"TimeSyncToken"`
}

// Walk : if the WalkHandlers.XElemsTimeSyncToken function is not nil (ie. was set by outside code), calls it with this XElemsTimeSyncToken instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsTimeSyncToken instance.
func (me *XElemsTimeSyncToken) Walk() (err error) {
	if fn := WalkHandlers.XElemsTimeSyncToken; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.TimeSyncTokens {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsSmartcard This element indicates that a smartcard is used to
// identity the Principal.
type XElemsSmartcard struct {
	//	This element indicates that a smartcard is used to
	//	identity the Principal.
	Smartcards []*TExtensionOnlyType `xml:"Smartcard"`
}

// Walk : if the WalkHandlers.XElemsSmartcard function is not nil (ie. was set by outside code), calls it with this XElemsSmartcard instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsSmartcard instance.
func (me *XElemsSmartcard) Walk() (err error) {
	if fn := WalkHandlers.XElemsSmartcard; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Smartcards {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsLength This element indicates the minimum and/or maximum ASCII length of the password which is enforced (by the UA or the IdP). In other words, this is the minimum and/or maximum number of ASCII characters required to represent a valid password. min - the minimum number of ASCII characters required in a valid password, as enforced by the UA or the IdP. max - the maximum number of ASCII characters required in a valid password, as enforced by the UA or the IdP.
type XElemsLength struct {
	//	This element indicates the minimum and/or maximum
	//	ASCII length of the password which is enforced (by the UA or the
	//	IdP). In other words, this is the minimum and/or maximum number of
	//	ASCII characters required to represent a valid password.
	//	min - the minimum number of ASCII characters required
	//	in a valid password, as enforced by the UA or the IdP.
	//	max - the maximum number of ASCII characters required
	//	in a valid password, as enforced by the UA or the IdP.
	Lengths []*TLengthType `xml:"Length"`
}

// Walk : if the WalkHandlers.XElemsLength function is not nil (ie. was set by outside code), calls it with this XElemsLength instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsLength instance.
func (me *XElemsLength) Walk() (err error) {
	if fn := WalkHandlers.XElemsLength; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Lengths {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsActivationLimit This element indicates the length of time for which an
// PIN-based authentication is valid.
type XElemsActivationLimit struct {
	//	This element indicates the length of time for which an
	//	PIN-based authentication is valid.
	ActivationLimits []*TActivationLimitType `xml:"ActivationLimit"`
}

// Walk : if the WalkHandlers.XElemsActivationLimit function is not nil (ie. was set by outside code), calls it with this XElemsActivationLimit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsActivationLimit instance.
func (me *XElemsActivationLimit) Walk() (err error) {
	if fn := WalkHandlers.XElemsActivationLimit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ActivationLimits {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsGeneration Indicates whether the password was chosen by the Principal or auto-supplied by the Authentication Authority. principalchosen - the Principal is allowed to choose the value of the password. This is true even if the initial password is chosen at random by the UA or the IdP and the Principal is then free to change the password. automatic - the password is chosen by the UA or the IdP to be cryptographically strong in some sense, or to satisfy certain password rules, and that the Principal is not free to change it or to choose a new password.
type XElemsGeneration struct {
	//	Indicates whether the password was chosen by the
	//	Principal or auto-supplied by the Authentication Authority.
	//	principalchosen - the Principal is allowed to choose
	//	the value of the password. This is true even if
	//	the initial password is chosen at random by the UA or
	//	the IdP and the Principal is then free to change
	//	the password.
	//	automatic - the password is chosen by the UA or the
	//	IdP to be cryptographically strong in some sense,
	//	or to satisfy certain password rules, and that the
	//	Principal is not free to change it or to choose a new password.
	Generations []*TxsdGeneration `xml:"Generation"`
}

// Walk : if the WalkHandlers.XElemsGeneration function is not nil (ie. was set by outside code), calls it with this XElemsGeneration instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsGeneration instance.
func (me *XElemsGeneration) Walk() (err error) {
	if fn := WalkHandlers.XElemsGeneration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Generations {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsAuthnMethod Refers to those characteristics that define the
// mechanisms by which the Principal authenticates to the Authentication
// Authority.
type XElemsAuthnMethod struct {
	//	Refers to those characteristics that define the
	//	mechanisms by which the Principal authenticates to the Authentication
	//	Authority.
	AuthnMethods []*TAuthnMethodBaseType `xml:"AuthnMethod"`
}

// Walk : if the WalkHandlers.XElemsAuthnMethod function is not nil (ie. was set by outside code), calls it with this XElemsAuthnMethod instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsAuthnMethod instance.
func (me *XElemsAuthnMethod) Walk() (err error) {
	if fn := WalkHandlers.XElemsAuthnMethod; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.AuthnMethods {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsPrincipalAuthenticationMechanism The method that a Principal employs to perform
// authentication to local system components.
type XElemsPrincipalAuthenticationMechanism struct {
	//	The method that a Principal employs to perform
	//	authentication to local system components.
	PrincipalAuthenticationMechanisms []*TPrincipalAuthenticationMechanismType `xml:"PrincipalAuthenticationMechanism"`
}

// Walk : if the WalkHandlers.XElemsPrincipalAuthenticationMechanism function is not nil (ie. was set by outside code), calls it with this XElemsPrincipalAuthenticationMechanism instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsPrincipalAuthenticationMechanism instance.
func (me *XElemsPrincipalAuthenticationMechanism) Walk() (err error) {
	if fn := WalkHandlers.XElemsPrincipalAuthenticationMechanism; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.PrincipalAuthenticationMechanisms {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsAuthenticator The method applied to validate a principal's
// authentication across a network
type XElemsAuthenticator struct {
	//	The method applied to validate a principal's
	//	authentication across a network
	Authenticators []*TAuthenticatorBaseType `xml:"Authenticator"`
}

// Walk : if the WalkHandlers.XElemsAuthenticator function is not nil (ie. was set by outside code), calls it with this XElemsAuthenticator instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsAuthenticator instance.
func (me *XElemsAuthenticator) Walk() (err error) {
	if fn := WalkHandlers.XElemsAuthenticator; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Authenticators {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsComplexAuthenticator Supports Authenticators with nested combinations of
// additional complexity.
type XElemsComplexAuthenticator struct {
	//	Supports Authenticators with nested combinations of
	//	additional complexity.
	ComplexAuthenticators []*TComplexAuthenticatorType `xml:"ComplexAuthenticator"`
}

// Walk : if the WalkHandlers.XElemsComplexAuthenticator function is not nil (ie. was set by outside code), calls it with this XElemsComplexAuthenticator instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsComplexAuthenticator instance.
func (me *XElemsComplexAuthenticator) Walk() (err error) {
	if fn := WalkHandlers.XElemsComplexAuthenticator; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ComplexAuthenticators {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsPreviousSession Indicates that the Principal has been strongly
// authenticated in a previous session during which the IdP has set a
// cookie in the UA. During the present session the Principal has only
// been authenticated by the UA returning the cookie to the IdP.
type XElemsPreviousSession struct {
	//	Indicates that the Principal has been strongly
	//	authenticated in a previous session during which the IdP has set a
	//	cookie in the UA. During the present session the Principal has only
	//	been authenticated by the UA returning the cookie to the IdP.
	PreviousSessions []*TExtensionOnlyType `xml:"PreviousSession"`
}

// Walk : if the WalkHandlers.XElemsPreviousSession function is not nil (ie. was set by outside code), calls it with this XElemsPreviousSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsPreviousSession instance.
func (me *XElemsPreviousSession) Walk() (err error) {
	if fn := WalkHandlers.XElemsPreviousSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.PreviousSessions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsResumeSession Rather like PreviousSession but using stronger
// security. A secret that was established in a previous session with
// the Authentication Authority has been cached by the local system and
// is now re-used (e.g. a Master Secret is used to derive new session
// keys in TLS, SSL, WTLS).
type XElemsResumeSession struct {
	//	Rather like PreviousSession but using stronger
	//	security. A secret that was established in a previous session with
	//	the Authentication Authority has been cached by the local system and
	//	is now re-used (e.g. a Master Secret is used to derive new session
	//	keys in TLS, SSL, WTLS).
	ResumeSessions []*TExtensionOnlyType `xml:"ResumeSession"`
}

// Walk : if the WalkHandlers.XElemsResumeSession function is not nil (ie. was set by outside code), calls it with this XElemsResumeSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsResumeSession instance.
func (me *XElemsResumeSession) Walk() (err error) {
	if fn := WalkHandlers.XElemsResumeSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ResumeSessions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsZeroKnowledge This element indicates that the Principal has been
// authenticated by a zero knowledge technique as specified in ISO/IEC
// 9798-5.
type XElemsZeroKnowledge struct {
	//	This element indicates that the Principal has been
	//	authenticated by a zero knowledge technique as specified in ISO/IEC
	//	9798-5.
	ZeroKnowledges []*TExtensionOnlyType `xml:"ZeroKnowledge"`
}

// Walk : if the WalkHandlers.XElemsZeroKnowledge function is not nil (ie. was set by outside code), calls it with this XElemsZeroKnowledge instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsZeroKnowledge instance.
func (me *XElemsZeroKnowledge) Walk() (err error) {
	if fn := WalkHandlers.XElemsZeroKnowledge; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ZeroKnowledges {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsSharedSecretChallengeResponse defines element SharedSecretChallengeResponse
type XElemsSharedSecretChallengeResponse struct {
	SharedSecretChallengeResponses []*TSharedSecretChallengeResponseType `xml:"SharedSecretChallengeResponse"`
}

// Walk : if the WalkHandlers.XElemsSharedSecretChallengeResponse function is not nil (ie. was set by outside code), calls it with this XElemsSharedSecretChallengeResponse instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsSharedSecretChallengeResponse instance.
func (me *XElemsSharedSecretChallengeResponse) Walk() (err error) {
	if fn := WalkHandlers.XElemsSharedSecretChallengeResponse; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SharedSecretChallengeResponses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsDigSig This element indicates that the Principal has been
// authenticated by a mechanism which involves the Principal computing a
// digital signature over at least challenge data provided by the IdP.
type XElemsDigSig struct {
	//	This element indicates that the Principal has been
	//	authenticated by a mechanism which involves the Principal computing a
	//	digital signature over at least challenge data provided by the IdP.
	DigSigs []*TPublicKeyType `xml:"DigSig"`
}

// Walk : if the WalkHandlers.XElemsDigSig function is not nil (ie. was set by outside code), calls it with this XElemsDigSig instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsDigSig instance.
func (me *XElemsDigSig) Walk() (err error) {
	if fn := WalkHandlers.XElemsDigSig; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.DigSigs {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsAsymmetricDecryption The local system has a private key but it is used
// in decryption mode, rather than signature mode. For example, the
// Authentication Authority generates a secret and encrypts it using the
// local system's public key: the local system then proves it has
// decrypted the secret.
type XElemsAsymmetricDecryption struct {
	//	The local system has a private key but it is used
	//	in decryption mode, rather than signature mode. For example, the
	//	Authentication Authority generates a secret and encrypts it using the
	//	local system's public key: the local system then proves it has
	//	decrypted the secret.
	AsymmetricDecryptions []*TPublicKeyType `xml:"AsymmetricDecryption"`
}

// Walk : if the WalkHandlers.XElemsAsymmetricDecryption function is not nil (ie. was set by outside code), calls it with this XElemsAsymmetricDecryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsAsymmetricDecryption instance.
func (me *XElemsAsymmetricDecryption) Walk() (err error) {
	if fn := WalkHandlers.XElemsAsymmetricDecryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.AsymmetricDecryptions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsAsymmetricKeyAgreement The local system has a private key and uses it for
// shared secret key agreement with the Authentication Authority (e.g.
// via Diffie Helman).
type XElemsAsymmetricKeyAgreement struct {
	//	The local system has a private key and uses it for
	//	shared secret key agreement with the Authentication Authority (e.g.
	//	via Diffie Helman).
	AsymmetricKeyAgreements []*TPublicKeyType `xml:"AsymmetricKeyAgreement"`
}

// Walk : if the WalkHandlers.XElemsAsymmetricKeyAgreement function is not nil (ie. was set by outside code), calls it with this XElemsAsymmetricKeyAgreement instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsAsymmetricKeyAgreement instance.
func (me *XElemsAsymmetricKeyAgreement) Walk() (err error) {
	if fn := WalkHandlers.XElemsAsymmetricKeyAgreement; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.AsymmetricKeyAgreements {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsIPAddress This element indicates that the Principal has been
// authenticated through connection from a particular IP address.
type XElemsIPAddress struct {
	//	This element indicates that the Principal has been
	//	authenticated through connection from a particular IP address.
	IPAddresses []*TExtensionOnlyType `xml:"IPAddress"`
}

// Walk : if the WalkHandlers.XElemsIPAddress function is not nil (ie. was set by outside code), calls it with this XElemsIPAddress instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsIPAddress instance.
func (me *XElemsIPAddress) Walk() (err error) {
	if fn := WalkHandlers.XElemsIPAddress; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.IPAddresses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsSharedSecretDynamicPlaintext The local system and Authentication Authority
// share a secret key. The local system uses this to encrypt a
// randomised string to pass to the Authentication Authority.
type XElemsSharedSecretDynamicPlaintext struct {
	//	The local system and Authentication Authority
	//	share a secret key. The local system uses this to encrypt a
	//	randomised string to pass to the Authentication Authority.
	SharedSecretDynamicPlaintexts []*TExtensionOnlyType `xml:"SharedSecretDynamicPlaintext"`
}

// Walk : if the WalkHandlers.XElemsSharedSecretDynamicPlaintext function is not nil (ie. was set by outside code), calls it with this XElemsSharedSecretDynamicPlaintext instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsSharedSecretDynamicPlaintext instance.
func (me *XElemsSharedSecretDynamicPlaintext) Walk() (err error) {
	if fn := WalkHandlers.XElemsSharedSecretDynamicPlaintext; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SharedSecretDynamicPlaintexts {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsAuthenticatorTransportProtocol The protocol across which Authenticator information is
// transferred to an Authentication Authority verifier.
type XElemsAuthenticatorTransportProtocol struct {
	//	The protocol across which Authenticator information is
	//	transferred to an Authentication Authority verifier.
	AuthenticatorTransportProtocols []*TAuthenticatorTransportProtocolType `xml:"AuthenticatorTransportProtocol"`
}

// Walk : if the WalkHandlers.XElemsAuthenticatorTransportProtocol function is not nil (ie. was set by outside code), calls it with this XElemsAuthenticatorTransportProtocol instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsAuthenticatorTransportProtocol instance.
func (me *XElemsAuthenticatorTransportProtocol) Walk() (err error) {
	if fn := WalkHandlers.XElemsAuthenticatorTransportProtocol; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.AuthenticatorTransportProtocols {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsHTTP This element indicates that the Authenticator has been
// transmitted using bare HTTP utilizing no additional security
// protocols.
type XElemsHTTP struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using bare HTTP utilizing no additional security
	//	protocols.
	HTTPS []*TExtensionOnlyType `xml:"HTTP"`
}

// Walk : if the WalkHandlers.XElemsHTTP function is not nil (ie. was set by outside code), calls it with this XElemsHTTP instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsHTTP instance.
func (me *XElemsHTTP) Walk() (err error) {
	if fn := WalkHandlers.XElemsHTTP; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.HTTPS {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsIPSec This element indicates that the Authenticator has been
// transmitted using a transport mechanism protected by an IPSEC session.
type XElemsIPSec struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechanism protected by an IPSEC session.
	IPSecs []*TExtensionOnlyType `xml:"IPSec"`
}

// Walk : if the WalkHandlers.XElemsIPSec function is not nil (ie. was set by outside code), calls it with this XElemsIPSec instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsIPSec instance.
func (me *XElemsIPSec) Walk() (err error) {
	if fn := WalkHandlers.XElemsIPSec; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.IPSecs {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsWtls This element indicates that the Authenticator has been
// transmitted using a transport mechanism protected by a WTLS session.
type XElemsWtls struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechanism protected by a WTLS session.
	Wtlses []*TExtensionOnlyType `xml:"WTLS"`
}

// Walk : if the WalkHandlers.XElemsWtls function is not nil (ie. was set by outside code), calls it with this XElemsWtls instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsWtls instance.
func (me *XElemsWtls) Walk() (err error) {
	if fn := WalkHandlers.XElemsWtls; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Wtlses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsMobileNetworkNoEncryption This element indicates that the Authenticator has been
// transmitted solely across a mobile network using no additional
// security mechanism.
type XElemsMobileNetworkNoEncryption struct {
	//	This element indicates that the Authenticator has been
	//	transmitted solely across a mobile network using no additional
	//	security mechanism.
	MobileNetworkNoEncryptions []*TExtensionOnlyType `xml:"MobileNetworkNoEncryption"`
}

// Walk : if the WalkHandlers.XElemsMobileNetworkNoEncryption function is not nil (ie. was set by outside code), calls it with this XElemsMobileNetworkNoEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsMobileNetworkNoEncryption instance.
func (me *XElemsMobileNetworkNoEncryption) Walk() (err error) {
	if fn := WalkHandlers.XElemsMobileNetworkNoEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.MobileNetworkNoEncryptions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsMobileNetworkRadioEncryption defines element MobileNetworkRadioEncryption
type XElemsMobileNetworkRadioEncryption struct {
	MobileNetworkRadioEncryptions []*TExtensionOnlyType `xml:"MobileNetworkRadioEncryption"`
}

// Walk : if the WalkHandlers.XElemsMobileNetworkRadioEncryption function is not nil (ie. was set by outside code), calls it with this XElemsMobileNetworkRadioEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsMobileNetworkRadioEncryption instance.
func (me *XElemsMobileNetworkRadioEncryption) Walk() (err error) {
	if fn := WalkHandlers.XElemsMobileNetworkRadioEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.MobileNetworkRadioEncryptions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsMobileNetworkEndToEndEncryption defines element MobileNetworkEndToEndEncryption
type XElemsMobileNetworkEndToEndEncryption struct {
	MobileNetworkEndToEndEncryptions []*TExtensionOnlyType `xml:"MobileNetworkEndToEndEncryption"`
}

// Walk : if the WalkHandlers.XElemsMobileNetworkEndToEndEncryption function is not nil (ie. was set by outside code), calls it with this XElemsMobileNetworkEndToEndEncryption instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsMobileNetworkEndToEndEncryption instance.
func (me *XElemsMobileNetworkEndToEndEncryption) Walk() (err error) {
	if fn := WalkHandlers.XElemsMobileNetworkEndToEndEncryption; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.MobileNetworkEndToEndEncryptions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsSsl This element indicates that the Authenticator has been
// transmitted using a transport mechnanism protected by an SSL or TLS
// session.
type XElemsSsl struct {
	//	This element indicates that the Authenticator has been
	//	transmitted using a transport mechnanism protected by an SSL or TLS
	//	session.
	Ssls []*TExtensionOnlyType `xml:"SSL"`
}

// Walk : if the WalkHandlers.XElemsSsl function is not nil (ie. was set by outside code), calls it with this XElemsSsl instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsSsl instance.
func (me *XElemsSsl) Walk() (err error) {
	if fn := WalkHandlers.XElemsSsl; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Ssls {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsPstn defines element Pstn
type XElemsPstn struct {
	Pstns []*TExtensionOnlyType `xml:"PSTN"`
}

// Walk : if the WalkHandlers.XElemsPstn function is not nil (ie. was set by outside code), calls it with this XElemsPstn instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsPstn instance.
func (me *XElemsPstn) Walk() (err error) {
	if fn := WalkHandlers.XElemsPstn; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Pstns {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsIsdn defines element Isdn
type XElemsIsdn struct {
	Isdns []*TExtensionOnlyType `xml:"ISDN"`
}

// Walk : if the WalkHandlers.XElemsIsdn function is not nil (ie. was set by outside code), calls it with this XElemsIsdn instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsIsdn instance.
func (me *XElemsIsdn) Walk() (err error) {
	if fn := WalkHandlers.XElemsIsdn; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Isdns {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsAdsl defines element Adsl
type XElemsAdsl struct {
	Adsls []*TExtensionOnlyType `xml:"ADSL"`
}

// Walk : if the WalkHandlers.XElemsAdsl function is not nil (ie. was set by outside code), calls it with this XElemsAdsl instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsAdsl instance.
func (me *XElemsAdsl) Walk() (err error) {
	if fn := WalkHandlers.XElemsAdsl; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Adsls {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsOperationalProtection Refers to those characteristics that describe
// procedural security controls employed by the Authentication Authority.
type XElemsOperationalProtection struct {
	//	Refers to those characteristics that describe
	//	procedural security controls employed by the Authentication Authority.
	OperationalProtections []*TOperationalProtectionType `xml:"OperationalProtection"`
}

// Walk : if the WalkHandlers.XElemsOperationalProtection function is not nil (ie. was set by outside code), calls it with this XElemsOperationalProtection instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsOperationalProtection instance.
func (me *XElemsOperationalProtection) Walk() (err error) {
	if fn := WalkHandlers.XElemsOperationalProtection; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.OperationalProtections {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsSecurityAudit defines element SecurityAudit
type XElemsSecurityAudit struct {
	SecurityAudits []*TSecurityAuditType `xml:"SecurityAudit"`
}

// Walk : if the WalkHandlers.XElemsSecurityAudit function is not nil (ie. was set by outside code), calls it with this XElemsSecurityAudit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsSecurityAudit instance.
func (me *XElemsSecurityAudit) Walk() (err error) {
	if fn := WalkHandlers.XElemsSecurityAudit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SecurityAudits {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsSwitchAudit defines element SwitchAudit
type XElemsSwitchAudit struct {
	SwitchAudits []*TExtensionOnlyType `xml:"SwitchAudit"`
}

// Walk : if the WalkHandlers.XElemsSwitchAudit function is not nil (ie. was set by outside code), calls it with this XElemsSwitchAudit instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsSwitchAudit instance.
func (me *XElemsSwitchAudit) Walk() (err error) {
	if fn := WalkHandlers.XElemsSwitchAudit; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.SwitchAudits {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsDeactivationCallCenter defines element DeactivationCallCenter
type XElemsDeactivationCallCenter struct {
	DeactivationCallCenters []*TExtensionOnlyType `xml:"DeactivationCallCenter"`
}

// Walk : if the WalkHandlers.XElemsDeactivationCallCenter function is not nil (ie. was set by outside code), calls it with this XElemsDeactivationCallCenter instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsDeactivationCallCenter instance.
func (me *XElemsDeactivationCallCenter) Walk() (err error) {
	if fn := WalkHandlers.XElemsDeactivationCallCenter; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.DeactivationCallCenters {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsGoverningAgreements Provides a mechanism for linking to external (likely
// human readable) documents in which additional business agreements,
// (e.g. liability constraints, obligations, etc) can be placed.
type XElemsGoverningAgreements struct {
	//	Provides a mechanism for linking to external (likely
	//	human readable) documents in which additional business agreements,
	//	(e.g. liability constraints, obligations, etc) can be placed.
	GoverningAgreementses []*TGoverningAgreementsType `xml:"GoverningAgreements"`
}

// Walk : if the WalkHandlers.XElemsGoverningAgreements function is not nil (ie. was set by outside code), calls it with this XElemsGoverningAgreements instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsGoverningAgreements instance.
func (me *XElemsGoverningAgreements) Walk() (err error) {
	if fn := WalkHandlers.XElemsGoverningAgreements; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.GoverningAgreementses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemGoverningAgreementRef defines element GoverningAgreementRef
type XElemGoverningAgreementRef struct {
	GoverningAgreementRef *TGoverningAgreementRefType `xml:"GoverningAgreementRef"`
}

// Walk : if the WalkHandlers.XElemGoverningAgreementRef function is not nil (ie. was set by outside code), calls it with this XElemGoverningAgreementRef instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemGoverningAgreementRef instance.
func (me *XElemGoverningAgreementRef) Walk() (err error) {
	if fn := WalkHandlers.XElemGoverningAgreementRef; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.GoverningAgreementRef.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsRestrictedPassword defines element RestrictedPassword
type XElemsRestrictedPassword struct {
	RestrictedPasswords []*TRestrictedPasswordType `xml:"RestrictedPassword"`
}

// Walk : if the WalkHandlers.XElemsRestrictedPassword function is not nil (ie. was set by outside code), calls it with this XElemsRestrictedPassword instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsRestrictedPassword instance.
func (me *XElemsRestrictedPassword) Walk() (err error) {
	if fn := WalkHandlers.XElemsRestrictedPassword; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.RestrictedPasswords {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsAlphabet defines element Alphabet
type XElemsAlphabet struct {
	Alphabets []*TAlphabetType `xml:"Alphabet"`
}

// Walk : if the WalkHandlers.XElemsAlphabet function is not nil (ie. was set by outside code), calls it with this XElemsAlphabet instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsAlphabet instance.
func (me *XElemsAlphabet) Walk() (err error) {
	if fn := WalkHandlers.XElemsAlphabet; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Alphabets {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsActivationLimitDuration This element indicates that the Key Activation Limit is
// defined as a specific duration of time.
type XElemsActivationLimitDuration struct {
	//	This element indicates that the Key Activation Limit is
	//	defined as a specific duration of time.
	ActivationLimitDurations []*TActivationLimitDurationType `xml:"ActivationLimitDuration"`
}

// Walk : if the WalkHandlers.XElemsActivationLimitDuration function is not nil (ie. was set by outside code), calls it with this XElemsActivationLimitDuration instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsActivationLimitDuration instance.
func (me *XElemsActivationLimitDuration) Walk() (err error) {
	if fn := WalkHandlers.XElemsActivationLimitDuration; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ActivationLimitDurations {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsActivationLimitUsages This element indicates that the Key Activation Limit is
// defined as a number of usages.
type XElemsActivationLimitUsages struct {
	//	This element indicates that the Key Activation Limit is
	//	defined as a number of usages.
	ActivationLimitUsageses []*TActivationLimitUsagesType `xml:"ActivationLimitUsages"`
}

// Walk : if the WalkHandlers.XElemsActivationLimitUsages function is not nil (ie. was set by outside code), calls it with this XElemsActivationLimitUsages instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsActivationLimitUsages instance.
func (me *XElemsActivationLimitUsages) Walk() (err error) {
	if fn := WalkHandlers.XElemsActivationLimitUsages; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ActivationLimitUsageses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsActivationLimitSession This element indicates that the Key Activation Limit is
// the session.
type XElemsActivationLimitSession struct {
	//	This element indicates that the Key Activation Limit is
	//	the session.
	ActivationLimitSessions []*TActivationLimitSessionType `xml:"ActivationLimitSession"`
}

// Walk : if the WalkHandlers.XElemsActivationLimitSession function is not nil (ie. was set by outside code), calls it with this XElemsActivationLimitSession instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsActivationLimitSession instance.
func (me *XElemsActivationLimitSession) Walk() (err error) {
	if fn := WalkHandlers.XElemsActivationLimitSession; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.ActivationLimitSessions {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemExtension defines element Extension
type XElemExtension struct {
	Extension *TExtensionType `xml:"Extension"`
}

// Walk : if the WalkHandlers.XElemExtension function is not nil (ie. was set by outside code), calls it with this XElemExtension instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemExtension instance.
func (me *XElemExtension) Walk() (err error) {
	if fn := WalkHandlers.XElemExtension; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Extension.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType defines element LengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType
type XElemsLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType struct {
	Lengths []*TRestrictedLengthType `xml:"Length"`
}

// Walk : if the WalkHandlers.XElemsLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType function is not nil (ie. was set by outside code), calls it with this XElemsLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType instance.
func (me *XElemsLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType) Walk() (err error) {
	if fn := WalkHandlers.XElemsLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Lengths {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XCdata defines type CDATA
type XCdata struct {
	XCDATA string `xml:",chardata"`
}

// Walk : if the WalkHandlers.XCdata function is not nil (ie. was set by outside code), calls it with this XCdata instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XCdata instance.
func (me *XCdata) Walk() (err error) {
	if fn := WalkHandlers.XCdata; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

var (
	// WalkContinueOnError can be set to false to break a Walk() immediately as soon as the first error is returned by a custom handler function.
	// If true, Walk() proceeds and accumulates all errors in the WalkErrors slice.
	WalkContinueOnError = true
	// WalkErrors contains all errors accumulated during Walk()s. If you're using this, you need to reset this yourself as needed prior to a fresh Walk().
	WalkErrors []error
	// WalkOnError is your custom error-handling function, if required.
	WalkOnError func(error)
	// WalkHandlers Provides 152 strong-typed hooks for your own custom handler functions to be invoked when the Walk() method is called on any instance of any (non-attribute-related) struct type defined in this package.
	// If your custom handler does get called at all for a given struct instance, then it always gets called twice, first with the 'enter' bool argument set to true, then (after having Walk()ed all subordinate struct instances, if any) once again with it set to false.
	WalkHandlers = &XWalkHandlers{}
)

// XWalkHandlers Provides 152 strong-typed hooks for your own custom handler functions to be invoked when the Walk() method is called on any instance of any (non-attribute-related) struct type defined in this package.
// If your custom handler does get called at all for a given struct instance, then it always gets called twice, first with the 'enter' bool argument set to true, then (after having Walk()ed all subordinate struct instances, if any) once again with it set to false.
type XWalkHandlers struct {
	XElemActivationLimit                                                                                 func(*XElemActivationLimit, bool) error
	TKeyStorageType                                                                                      func(*TKeyStorageType, bool) error
	XElemPrivateKeyProtection                                                                            func(*XElemPrivateKeyProtection, bool) error
	XElemPrincipalAuthenticationMechanism                                                                func(*XElemPrincipalAuthenticationMechanism, bool) error
	XElemSharedSecretDynamicPlaintext                                                                    func(*XElemSharedSecretDynamicPlaintext, bool) error
	XElemsComplexAuthenticator                                                                           func(*XElemsComplexAuthenticator, bool) error
	XElemTechnicalProtection                                                                             func(*XElemTechnicalProtection, bool) error
	XElemAuthenticationContextDeclaration                                                                func(*XElemAuthenticationContextDeclaration, bool) error
	XElemsUserSuffix                                                                                     func(*XElemsUserSuffix, bool) error
	XElemsSharedSecretDynamicPlaintext                                                                   func(*XElemsSharedSecretDynamicPlaintext, bool) error
	XElemGeneration                                                                                      func(*XElemGeneration, bool) error
	XElemActivationLimitDuration                                                                         func(*XElemActivationLimitDuration, bool) error
	XElemToken                                                                                           func(*XElemToken, bool) error
	XElemAuthenticatorTransportProtocol                                                                  func(*XElemAuthenticatorTransportProtocol, bool) error
	XElemsSmartcard                                                                                      func(*XElemsSmartcard, bool) error
	XElemsGeneration                                                                                     func(*XElemsGeneration, bool) error
	XElemsMobileNetworkEndToEndEncryption                                                                func(*XElemsMobileNetworkEndToEndEncryption, bool) error
	TActivationLimitDurationType                                                                         func(*TActivationLimitDurationType, bool) error
	XElemMobileNetworkEndToEndEncryption                                                                 func(*XElemMobileNetworkEndToEndEncryption, bool) error
	XElemsSharedSecretChallengeResponse                                                                  func(*XElemsSharedSecretChallengeResponse, bool) error
	TGoverningAgreementRefType                                                                           func(*TGoverningAgreementRefType, bool) error
	XElemActivationLimitSession                                                                          func(*XElemActivationLimitSession, bool) error
	TSecurityAuditType                                                                                   func(*TSecurityAuditType, bool) error
	TPasswordType                                                                                        func(*TPasswordType, bool) error
	XGroupAuthenticatorChoiceGroup                                                                       func(*XGroupAuthenticatorChoiceGroup, bool) error
	XElemPstn                                                                                            func(*XElemPstn, bool) error
	XElemsLength                                                                                         func(*XElemsLength, bool) error
	XElemsMobileNetworkRadioEncryption                                                                   func(*XElemsMobileNetworkRadioEncryption, bool) error
	XElemsSecurityAudit                                                                                  func(*XElemsSecurityAudit, bool) error
	XElemsSwitchAudit                                                                                    func(*XElemsSwitchAudit, bool) error
	XElemsGoverningAgreementRef                                                                          func(*XElemsGoverningAgreementRef, bool) error
	TxsdGeneration                                                                                       func(*TxsdGeneration, bool) error
	XElemSecretKeyProtection                                                                             func(*XElemSecretKeyProtection, bool) error
	XElemRestrictedPassword                                                                              func(*XElemRestrictedPassword, bool) error
	XElemsWrittenConsent                                                                                 func(*XElemsWrittenConsent, bool) error
	XElemsAuthenticator                                                                                  func(*XElemsAuthenticator, bool) error
	TGoverningAgreementsType                                                                             func(*TGoverningAgreementsType, bool) error
	XElemPassword                                                                                        func(*XElemPassword, bool) error
	XElemResumeSession                                                                                   func(*XElemResumeSession, bool) error
	TAuthnMethodBaseType                                                                                 func(*TAuthnMethodBaseType, bool) error
	XElemsIPSec                                                                                          func(*XElemsIPSec, bool) error
	XElemsRestrictedPassword                                                                             func(*XElemsRestrictedPassword, bool) error
	XElemsActivationLimitSession                                                                         func(*XElemsActivationLimitSession, bool) error
	TLengthType                                                                                          func(*TLengthType, bool) error
	XElemKeySharing                                                                                      func(*XElemKeySharing, bool) error
	XElemDeactivationCallCenter                                                                          func(*XElemDeactivationCallCenter, bool) error
	XElemUserSuffix                                                                                      func(*XElemUserSuffix, bool) error
	XElemAuthnMethod                                                                                     func(*XElemAuthnMethod, bool) error
	XElemsPrivateKeyProtection                                                                           func(*XElemsPrivateKeyProtection, bool) error
	XElemsWtls                                                                                           func(*XElemsWtls, bool) error
	TRestrictedPasswordType                                                                              func(*TRestrictedPasswordType, bool) error
	TimeSyncTokenType                                                                                    func(*TimeSyncTokenType, bool) error
	XElemSubscriberLineNumber                                                                            func(*XElemSubscriberLineNumber, bool) error
	XElemSsl                                                                                             func(*XElemSsl, bool) error
	XElemMobileNetworkRadioEncryption                                                                    func(*XElemMobileNetworkRadioEncryption, bool) error
	XElemMobileNetworkNoEncryption                                                                       func(*XElemMobileNetworkNoEncryption, bool) error
	TAuthnContextDeclarationBaseType                                                                     func(*TAuthnContextDeclarationBaseType, bool) error
	XElemsAuthenticationContextDeclaration                                                               func(*XElemsAuthenticationContextDeclaration, bool) error
	XElemsPassword                                                                                       func(*XElemsPassword, bool) error
	XCdata                                                                                               func(*XCdata, bool) error
	TActivationLimitType                                                                                 func(*TActivationLimitType, bool) error
	TokenType                                                                                            func(*TokenType, bool) error
	XElemsKeyActivation                                                                                  func(*XElemsKeyActivation, bool) error
	XElemsDeactivationCallCenter                                                                         func(*XElemsDeactivationCallCenter, bool) error
	XElemsExtension                                                                                      func(*XElemsExtension, bool) error
	TxsdPhysicalVerification                                                                             func(*TxsdPhysicalVerification, bool) error
	XGroupAuthenticatorSequenceGroup                                                                     func(*XGroupAuthenticatorSequenceGroup, bool) error
	XElemComplexAuthenticator                                                                            func(*XElemComplexAuthenticator, bool) error
	XElemsIsdn                                                                                           func(*XElemsIsdn, bool) error
	TPrivateKeyProtectionType                                                                            func(*TPrivateKeyProtectionType, bool) error
	XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType  func(*XElemLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType, bool) error
	XElemsSubscriberLineNumber                                                                           func(*XElemsSubscriberLineNumber, bool) error
	TExtensionType                                                                                       func(*TExtensionType, bool) error
	TRestrictedLengthType                                                                                func(*TRestrictedLengthType, bool) error
	XElemAsymmetricDecryption                                                                            func(*XElemAsymmetricDecryption, bool) error
	XElemAdsl                                                                                            func(*XElemAdsl, bool) error
	XElemsZeroKnowledge                                                                                  func(*XElemsZeroKnowledge, bool) error
	XElemActivationLimitUsages                                                                           func(*XElemActivationLimitUsages, bool) error
	TKeySharingType                                                                                      func(*TKeySharingType, bool) error
	XElemZeroKnowledge                                                                                   func(*XElemZeroKnowledge, bool) error
	XElemWtls                                                                                            func(*XElemWtls, bool) error
	XElemsKeySharing                                                                                     func(*XElemsKeySharing, bool) error
	XElemsAdsl                                                                                           func(*XElemsAdsl, bool) error
	XElemHTTP                                                                                            func(*XElemHTTP, bool) error
	XElemsSsl                                                                                            func(*XElemsSsl, bool) error
	TIdentificationType                                                                                  func(*TIdentificationType, bool) error
	TAlphabetType                                                                                        func(*TAlphabetType, bool) error
	TActivationLimitUsagesType                                                                           func(*TActivationLimitUsagesType, bool) error
	XElemGoverningAgreementRef                                                                           func(*XElemGoverningAgreementRef, bool) error
	XElemKeyStorage                                                                                      func(*XElemKeyStorage, bool) error
	XElemDigSig                                                                                          func(*XElemDigSig, bool) error
	XElemsToken                                                                                          func(*XElemsToken, bool) error
	XElemsAuthnMethod                                                                                    func(*XElemsAuthnMethod, bool) error
	XElemsPstn                                                                                           func(*XElemsPstn, bool) error
	XElemsGoverningAgreements                                                                            func(*XElemsGoverningAgreements, bool) error
	XElemsAlphabet                                                                                       func(*XElemsAlphabet, bool) error
	XElemsActivationLimitDuration                                                                        func(*XElemsActivationLimitDuration, bool) error
	TExtensionOnlyType                                                                                   func(*TExtensionOnlyType, bool) error
	XElemsPhysicalVerification                                                                           func(*XElemsPhysicalVerification, bool) error
	XElemsOperationalProtection                                                                          func(*XElemsOperationalProtection, bool) error
	TComplexAuthenticatorType                                                                            func(*TComplexAuthenticatorType, bool) error
	XElemsLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType func(*XElemsLengthsequencerestrictioncomplexContentRestrictedPasswordTypeschemaLengthTRestrictedLengthType, bool) error
	TechnicalProtectionBaseType                                                                          func(*TechnicalProtectionBaseType, bool) error
	TOperationalProtectionType                                                                           func(*TOperationalProtectionType, bool) error
	XElemOperationalProtection                                                                           func(*XElemOperationalProtection, bool) error
	XElemSharedSecretChallengeResponse                                                                   func(*XElemSharedSecretChallengeResponse, bool) error
	XElemsDigSig                                                                                         func(*XElemsDigSig, bool) error
	XElemPhysicalVerification                                                                            func(*XElemPhysicalVerification, bool) error
	XElemsIdentification                                                                                 func(*XElemsIdentification, bool) error
	XElemsResumeSession                                                                                  func(*XElemsResumeSession, bool) error
	XElemActivationPin                                                                                   func(*XElemActivationPin, bool) error
	XElemSwitchAudit                                                                                     func(*XElemSwitchAudit, bool) error
	XElemIPAddress                                                                                       func(*XElemIPAddress, bool) error
	XElemPreviousSession                                                                                 func(*XElemPreviousSession, bool) error
	XElemsAsymmetricKeyAgreement                                                                         func(*XElemsAsymmetricKeyAgreement, bool) error
	XElemAsymmetricKeyAgreement                                                                          func(*XElemAsymmetricKeyAgreement, bool) error
	XElemIPSec                                                                                           func(*XElemIPSec, bool) error
	XElemsAsymmetricDecryption                                                                           func(*XElemsAsymmetricDecryption, bool) error
	XElemsAuthenticatorTransportProtocol                                                                 func(*XElemsAuthenticatorTransportProtocol, bool) error
	TActivationLimitSessionType                                                                          func(*TActivationLimitSessionType, bool) error
	XElemSmartcard                                                                                       func(*XElemSmartcard, bool) error
	XElemsActivationPin                                                                                  func(*XElemsActivationPin, bool) error
	XElemsPrincipalAuthenticationMechanism                                                               func(*XElemsPrincipalAuthenticationMechanism, bool) error
	XElemGoverningAgreements                                                                             func(*XElemGoverningAgreements, bool) error
	XElemWrittenConsent                                                                                  func(*XElemWrittenConsent, bool) error
	TSecretKeyProtectionType                                                                             func(*TSecretKeyProtectionType, bool) error
	XElemsTechnicalProtection                                                                            func(*XElemsTechnicalProtection, bool) error
	XElemLength                                                                                          func(*XElemLength, bool) error
	XElemKeyActivation                                                                                   func(*XElemKeyActivation, bool) error
	XElemSecurityAudit                                                                                   func(*XElemSecurityAudit, bool) error
	TAuthenticatorBaseType                                                                               func(*TAuthenticatorBaseType, bool) error
	XElemsSecretKeyProtection                                                                            func(*XElemsSecretKeyProtection, bool) error
	XElemsActivationLimit                                                                                func(*XElemsActivationLimit, bool) error
	XElemExtension                                                                                       func(*XElemExtension, bool) error
	TSharedSecretChallengeResponseType                                                                   func(*TSharedSecretChallengeResponseType, bool) error
	XElemIsdn                                                                                            func(*XElemIsdn, bool) error
	XElemsMobileNetworkNoEncryption                                                                      func(*XElemsMobileNetworkNoEncryption, bool) error
	XElemsActivationLimitUsages                                                                          func(*XElemsActivationLimitUsages, bool) error
	XElemIdentification                                                                                  func(*XElemIdentification, bool) error
	TKeyActivationType                                                                                   func(*TKeyActivationType, bool) error
	XElemTimeSyncToken                                                                                   func(*XElemTimeSyncToken, bool) error
	TPublicKeyType                                                                                       func(*TPublicKeyType, bool) error
	XElemAuthenticator                                                                                   func(*XElemAuthenticator, bool) error
	TAuthenticatorTransportProtocolType                                                                  func(*TAuthenticatorTransportProtocolType, bool) error
	XElemsKeyStorage                                                                                     func(*XElemsKeyStorage, bool) error
	XElemsTimeSyncToken                                                                                  func(*XElemsTimeSyncToken, bool) error
	XElemsIPAddress                                                                                      func(*XElemsIPAddress, bool) error
	XElemsHTTP                                                                                           func(*XElemsHTTP, bool) error
	XElemAlphabet                                                                                        func(*XElemAlphabet, bool) error
	TActivationPinType                                                                                   func(*TActivationPinType, bool) error
	TPrincipalAuthenticationMechanismType                                                                func(*TPrincipalAuthenticationMechanismType, bool) error
	XElemsPreviousSession                                                                                func(*XElemsPreviousSession, bool) error
}
