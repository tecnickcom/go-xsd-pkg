// Package goSamlEcp20 : autogenerated from XSD schema and manually adjusted (Nicola Asuni - 2016-11-03)
package goSamlEcp20

//	Document identifier: saml-schema-ecp-2.0 Location: http://docs.oasis-open.org/security/saml/v2.0/ Revision history: V2.0 (March, 2005): Custom schema for ECP profile, first published in SAML 2.0.

import (
	saml "github.com/miracl/go-xsd-pkg/docs.oasis-open.org/security/saml/v2.0/saml-schema-assertion-2.0.xsd_go"
	samlp "github.com/miracl/go-xsd-pkg/docs.oasis-open.org/security/saml/v2.0/saml-schema-protocol-2.0.xsd_go"
	S "github.com/miracl/go-xsd-pkg/schemas.xmlsoap.org/soap/envelope_go"
	xsdt "github.com/miracl/go-xsd-pkg/xsdt"
)

// XAttrProviderNameXsdtString defines attribute ProviderName
type XAttrProviderNameXsdtString struct {
	ProviderName xsdt.String `xml:"ProviderName,attr"`
}

// XAttrIsPassiveXsdtBoolean defines attribute IsPassive
type XAttrIsPassiveXsdtBoolean struct {
	IsPassive xsdt.Boolean `xml:"IsPassive,attr"`
}

// TRequestType defines type RequestType
type TRequestType struct {
	samlp.XElemIDPList
	S.XAttrActor
	XAttrProviderNameXsdtString
	XAttrIsPassiveXsdtBoolean
	S.XAttrMustUnderstand
	saml.XElemIssuer
}

// Walk : if the WalkHandlers.TRequestType function is not nil (ie. was set by outside code), calls it with this TRequestType instance as the single argument. Then calls the Walk() method on 0/6 embed(s) and 0/0 field(s) belonging to this TRequestType instance.
func (me *TRequestType) Walk() (err error) {
	if fn := WalkHandlers.TRequestType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemRequest defines element Request
type XElemRequest struct {
	Request *TRequestType `xml:"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp Request"`
}

// Walk : if the WalkHandlers.XElemRequest function is not nil (ie. was set by outside code), calls it with this XElemRequest instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemRequest instance.
func (me *XElemRequest) Walk() (err error) {
	if fn := WalkHandlers.XElemRequest; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Request.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsRequest defines element Request
type XElemsRequest struct {
	Requests []*TRequestType `xml:"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp Request"`
}

// Walk : if the WalkHandlers.XElemsRequest function is not nil (ie. was set by outside code), calls it with this XElemsRequest instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsRequest instance.
func (me *XElemsRequest) Walk() (err error) {
	if fn := WalkHandlers.XElemsRequest; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Requests {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XAttrAssertionConsumerServiceURLXsdtAnyURI defines attribute AssertionConsumerServiceURL
type XAttrAssertionConsumerServiceURLXsdtAnyURI struct {
	AssertionConsumerServiceURL xsdt.AnyURI `xml:"AssertionConsumerServiceURL,attr"`
}

// TResponseType defines type ResponseType
type TResponseType struct {
	S.XAttrMustUnderstand
	S.XAttrActor
	XAttrAssertionConsumerServiceURLXsdtAnyURI
}

// Walk : if the WalkHandlers.TResponseType function is not nil (ie. was set by outside code), calls it with this TResponseType instance as the single argument. Then calls the Walk() method on 0/3 embed(s) and 0/0 field(s) belonging to this TResponseType instance.
func (me *TResponseType) Walk() (err error) {
	if fn := WalkHandlers.TResponseType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemResponse defines element Response
type XElemResponse struct {
	Response *TResponseType `xml:"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp Response"`
}

// Walk : if the WalkHandlers.XElemResponse function is not nil (ie. was set by outside code), calls it with this XElemResponse instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemResponse instance.
func (me *XElemResponse) Walk() (err error) {
	if fn := WalkHandlers.XElemResponse; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.Response.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsResponse defines element Response
type XElemsResponse struct {
	Responses []*TResponseType `xml:"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp Response"`
}

// Walk : if the WalkHandlers.XElemsResponse function is not nil (ie. was set by outside code), calls it with this XElemsResponse instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsResponse instance.
func (me *XElemsResponse) Walk() (err error) {
	if fn := WalkHandlers.XElemsResponse; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.Responses {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// TRelayStateType defines type RelayStateType
type TRelayStateType struct {
	XCdata
	S.XAttrMustUnderstand
	S.XAttrActor
}

// Walk : if the WalkHandlers.TRelayStateType function is not nil (ie. was set by outside code), calls it with this TRelayStateType instance as the single argument. Then calls the Walk() method on 0/3 embed(s) and 0/0 field(s) belonging to this TRelayStateType instance.
func (me *TRelayStateType) Walk() (err error) {
	if fn := WalkHandlers.TRelayStateType; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemRelayState defines element RelayState
type XElemRelayState struct {
	RelayState *TRelayStateType `xml:"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp RelayState"`
}

// Walk : if the WalkHandlers.XElemRelayState function is not nil (ie. was set by outside code), calls it with this XElemRelayState instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 1/1 field(s) belonging to this XElemRelayState instance.
func (me *XElemRelayState) Walk() (err error) {
	if fn := WalkHandlers.XElemRelayState; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if err = me.RelayState.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
			return
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XElemsRelayState defines element RelayState
type XElemsRelayState struct {
	RelayStates []*TRelayStateType `xml:"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp RelayState"`
}

// Walk : if the WalkHandlers.XElemsRelayState function is not nil (ie. was set by outside code), calls it with this XElemsRelayState instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XElemsRelayState instance.
func (me *XElemsRelayState) Walk() (err error) {
	if fn := WalkHandlers.XElemsRelayState; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		for _, x := range me.RelayStates {
			if err = x.Walk(); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

// XCdata defines type CDATA
type XCdata struct {
	XCDATA string `xml:",chardata"`
}

// Walk : if the WalkHandlers.XCdata function is not nil (ie. was set by outside code), calls it with this XCdata instance as the single argument. Then calls the Walk() method on 0/0 embed(s) and 0/1 field(s) belonging to this XCdata instance.
func (me *XCdata) Walk() (err error) {
	if fn := WalkHandlers.XCdata; me != nil {
		if fn != nil {
			if err = fn(me, true); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
		if fn != nil {
			if err = fn(me, false); xsdt.OnWalkError(&err, &WalkErrors, WalkContinueOnError, WalkOnError) {
				return
			}
		}
	}
	return
}

var (
	// WalkContinueOnError can be set to false to break a Walk() immediately as soon as the first error is returned by a custom handler function.
	// If true, Walk() proceeds and accumulates all errors in the WalkErrors slice.
	WalkContinueOnError = true
	// WalkErrors contains all errors accumulated during Walk()s. If you're using this, you need to reset this yourself as needed prior to a fresh Walk().
	WalkErrors []error
	// WalkOnError is your custom error-handling function, if required.
	WalkOnError func(error)
	// WalkHandlers Provides 10 strong-typed hooks for your own custom handler functions to be invoked when the Walk() method is called on any instance of any (non-attribute-related) struct type defined in this package.
	// If your custom handler does get called at all for a given struct instance, then it always gets called twice, first with the 'enter' bool argument set to true, then (after having Walk()ed all subordinate struct instances, if any) once again with it set to false.
	WalkHandlers = &XWalkHandlers{}
)

// XWalkHandlers Provides 10 strong-typed hooks for your own custom handler functions to be invoked when the Walk() method is called on any instance of any (non-attribute-related) struct type defined in this package.
// If your custom handler does get called at all for a given struct instance, then it always gets called twice, first with the 'enter' bool argument set to true, then (after having Walk()ed all subordinate struct instances, if any) once again with it set to false.
type XWalkHandlers struct {
	TRequestType     func(*TRequestType, bool) error
	XElemsRequest    func(*XElemsRequest, bool) error
	TResponseType    func(*TResponseType, bool) error
	XElemResponse    func(*XElemResponse, bool) error
	XElemRelayState  func(*XElemRelayState, bool) error
	XElemRequest     func(*XElemRequest, bool) error
	XElemsResponse   func(*XElemsResponse, bool) error
	TRelayStateType  func(*TRelayStateType, bool) error
	XElemsRelayState func(*XElemsRelayState, bool) error
	XCdata           func(*XCdata, bool) error
}
